{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Directive, InjectionToken, Optional, SkipSelf, Inject, Injectable, inject, Injector, ViewContainerRef, EventEmitter, NgZone, ElementRef, InjectFlags, Input, Output, ContentChildren, NgModule } from '@angular/core';\nimport { Overlay, OverlayConfig, STANDARD_DROPDOWN_BELOW_POSITIONS, STANDARD_DROPDOWN_ADJACENT_POSITIONS, OverlayModule } from '@angular/cdk/overlay';\nimport { UP_ARROW, hasModifierKey, DOWN_ARROW, LEFT_ARROW, RIGHT_ARROW, ENTER, SPACE, TAB, ESCAPE } from '@angular/cdk/keycodes';\nimport { startWith, debounceTime, distinctUntilChanged, filter, takeUntil, mergeMap, mapTo, mergeAll, switchMap, skip } from 'rxjs/operators';\nimport { UniqueSelectionDispatcher } from '@angular/cdk/collections';\nimport { Subject, merge, fromEvent, defer, partition } from 'rxjs';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { FocusKeyManager } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Directionality } from '@angular/cdk/bidi';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A grouping container for `CdkMenuItemRadio` instances, similar to a `role=\"radiogroup\"` element.\n */\n\nclass CdkMenuGroup {}\n\nCdkMenuGroup.ɵfac = function CdkMenuGroup_Factory(t) {\n  return new (t || CdkMenuGroup)();\n};\n\nCdkMenuGroup.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: CdkMenuGroup,\n  selectors: [[\"\", \"cdkMenuGroup\", \"\"]],\n  hostAttrs: [\"role\", \"group\", 1, \"cdk-menu-group\"],\n  exportAs: [\"cdkMenuGroup\"],\n  features: [i0.ɵɵProvidersFeature([{\n    provide: UniqueSelectionDispatcher,\n    useClass: UniqueSelectionDispatcher\n  }])]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuGroup, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkMenuGroup]',\n      exportAs: 'cdkMenuGroup',\n      host: {\n        'role': 'group',\n        'class': 'cdk-menu-group'\n      },\n      providers: [{\n        provide: UniqueSelectionDispatcher,\n        useClass: UniqueSelectionDispatcher\n      }]\n    }]\n  }], null, null);\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Injection token used to return classes implementing the Menu interface */\n\n\nconst CDK_MENU = new InjectionToken('cdk-menu');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Injection token used for an implementation of MenuStack. */\n\nconst MENU_STACK = new InjectionToken('cdk-menu-stack');\n/** Provider that provides the parent menu stack, or a new menu stack if there is no parent one. */\n\nconst PARENT_OR_NEW_MENU_STACK_PROVIDER = {\n  provide: MENU_STACK,\n  deps: [[new Optional(), new SkipSelf(), new Inject(MENU_STACK)]],\n  useFactory: parentMenuStack => parentMenuStack || new MenuStack()\n};\n/** Provider that provides the parent menu stack, or a new inline menu stack if there is no parent one. */\n\nconst PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER = orientation => ({\n  provide: MENU_STACK,\n  deps: [[new Optional(), new SkipSelf(), new Inject(MENU_STACK)]],\n  useFactory: parentMenuStack => parentMenuStack || MenuStack.inline(orientation)\n});\n/** The next available menu stack ID. */\n\n\nlet nextId$2 = 0;\n/**\n * MenuStack allows subscribers to listen for close events (when a MenuStackItem is popped off\n * of the stack) in order to perform closing actions. Upon the MenuStack being empty it emits\n * from the `empty` observable specifying the next focus action which the listener should perform\n * as requested by the closer.\n */\n\nclass MenuStack {\n  constructor() {\n    /** The ID of this menu stack. */\n    this.id = `${nextId$2++}`;\n    /** All MenuStackItems tracked by this MenuStack. */\n\n    this._elements = [];\n    /** Emits the element which was popped off of the stack when requested by a closer. */\n\n    this._close = new Subject();\n    /** Emits once the MenuStack has become empty after popping off elements. */\n\n    this._empty = new Subject();\n    /** Emits whether any menu in the menu stack has focus. */\n\n    this._hasFocus = new Subject();\n    /** Observable which emits the MenuStackItem which has been requested to close. */\n\n    this.closed = this._close;\n    /** Observable which emits whether any menu in the menu stack has focus. */\n\n    this.hasFocus = this._hasFocus.pipe(startWith(false), debounceTime(0), distinctUntilChanged());\n    /**\n     * Observable which emits when the MenuStack is empty after popping off the last element. It\n     * emits a FocusNext event which specifies the action the closer has requested the listener\n     * perform.\n     */\n\n    this.emptied = this._empty;\n    /**\n     * Whether the inline menu associated with this menu stack is vertical or horizontal.\n     * `null` indicates there is no inline menu associated with this menu stack.\n     */\n\n    this._inlineMenuOrientation = null;\n  }\n  /** Creates a menu stack that originates from an inline menu. */\n\n\n  static inline(orientation) {\n    const stack = new MenuStack();\n    stack._inlineMenuOrientation = orientation;\n    return stack;\n  }\n  /**\n   * Adds an item to the menu stack.\n   * @param menu the MenuStackItem to put on the stack.\n   */\n\n\n  push(menu) {\n    this._elements.push(menu);\n  }\n  /**\n   * Pop items off of the stack up to and including `lastItem` and emit each on the close\n   * observable. If the stack is empty or `lastItem` is not on the stack it does nothing.\n   * @param lastItem the last item to pop off the stack.\n   * @param options Options that configure behavior on close.\n   */\n\n\n  close(lastItem, options) {\n    const {\n      focusNextOnEmpty,\n      focusParentTrigger\n    } = { ...options\n    };\n\n    if (this._elements.indexOf(lastItem) >= 0) {\n      let poppedElement;\n\n      do {\n        poppedElement = this._elements.pop();\n\n        this._close.next({\n          item: poppedElement,\n          focusParentTrigger\n        });\n      } while (poppedElement !== lastItem);\n\n      if (this.isEmpty()) {\n        this._empty.next(focusNextOnEmpty);\n      }\n    }\n  }\n  /**\n   * Pop items off of the stack up to but excluding `lastItem` and emit each on the close\n   * observable. If the stack is empty or `lastItem` is not on the stack it does nothing.\n   * @param lastItem the element which should be left on the stack\n   * @return whether or not an item was removed from the stack\n   */\n\n\n  closeSubMenuOf(lastItem) {\n    let removed = false;\n\n    if (this._elements.indexOf(lastItem) >= 0) {\n      removed = this.peek() !== lastItem;\n\n      while (this.peek() !== lastItem) {\n        this._close.next({\n          item: this._elements.pop()\n        });\n      }\n    }\n\n    return removed;\n  }\n  /**\n   * Pop off all MenuStackItems and emit each one on the `close` observable one by one.\n   * @param options Options that configure behavior on close.\n   */\n\n\n  closeAll(options) {\n    const {\n      focusNextOnEmpty,\n      focusParentTrigger\n    } = { ...options\n    };\n\n    if (!this.isEmpty()) {\n      while (!this.isEmpty()) {\n        const menuStackItem = this._elements.pop();\n\n        if (menuStackItem) {\n          this._close.next({\n            item: menuStackItem,\n            focusParentTrigger\n          });\n        }\n      }\n\n      this._empty.next(focusNextOnEmpty);\n    }\n  }\n  /** Return true if this stack is empty. */\n\n\n  isEmpty() {\n    return !this._elements.length;\n  }\n  /** Return the length of the stack. */\n\n\n  length() {\n    return this._elements.length;\n  }\n  /** Get the top most element on the stack. */\n\n\n  peek() {\n    return this._elements[this._elements.length - 1];\n  }\n  /** Whether the menu stack is associated with an inline menu. */\n\n\n  hasInlineMenu() {\n    return this._inlineMenuOrientation != null;\n  }\n  /** The orientation of the associated inline menu. */\n\n\n  inlineMenuOrientation() {\n    return this._inlineMenuOrientation;\n  }\n  /** Sets whether the menu stack contains the focused element. */\n\n\n  setHasFocus(hasFocus) {\n    this._hasFocus.next(hasFocus);\n  }\n\n}\n\nMenuStack.ɵfac = function MenuStack_Factory(t) {\n  return new (t || MenuStack)();\n};\n\nMenuStack.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: MenuStack,\n  factory: MenuStack.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MenuStack, [{\n    type: Injectable\n  }], null, null);\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Injection token used for an implementation of MenuStack. */\n\n\nconst MENU_TRIGGER = new InjectionToken('cdk-menu-trigger');\n/**\n * Abstract directive that implements shared logic common to all menu triggers.\n * This class can be extended to create custom menu trigger types.\n */\n\nclass CdkMenuTriggerBase {\n  constructor() {\n    /** The DI injector for this component. */\n    this.injector = inject(Injector);\n    /** The view container ref for this component */\n\n    this.viewContainerRef = inject(ViewContainerRef);\n    /** The menu stack in which this menu resides. */\n\n    this.menuStack = inject(MENU_STACK);\n    /** Emits when the attached menu is requested to open */\n\n    this.opened = new EventEmitter();\n    /** Emits when the attached menu is requested to close */\n\n    this.closed = new EventEmitter();\n    /** A reference to the overlay which manages the triggered menu */\n\n    this.overlayRef = null;\n    /** Emits when this trigger is destroyed. */\n\n    this.destroyed = new Subject();\n    /** Emits when the outside pointer events listener on the overlay should be stopped. */\n\n    this.stopOutsideClicksListener = merge(this.closed, this.destroyed);\n  }\n\n  ngOnDestroy() {\n    this._destroyOverlay();\n\n    this.destroyed.next();\n    this.destroyed.complete();\n  }\n  /** Whether the attached menu is open. */\n\n\n  isOpen() {\n    return !!this.overlayRef?.hasAttached();\n  }\n  /** Registers a child menu as having been opened by this trigger. */\n\n\n  registerChildMenu(child) {\n    this.childMenu = child;\n  }\n  /**\n   * Get the portal to be attached to the overlay which contains the menu. Allows for the menu\n   * content to change dynamically and be reflected in the application.\n   */\n\n\n  getMenuContentPortal() {\n    const hasMenuContentChanged = this.menuTemplateRef !== this._menuPortal?.templateRef;\n\n    if (this.menuTemplateRef && (!this._menuPortal || hasMenuContentChanged)) {\n      this._menuPortal = new TemplatePortal(this.menuTemplateRef, this.viewContainerRef, undefined, this._getChildMenuInjector());\n    }\n\n    return this._menuPortal;\n  }\n  /**\n   * Whether the given element is inside the scope of this trigger's menu stack.\n   * @param element The element to check.\n   * @return Whether the element is inside the scope of this trigger's menu stack.\n   */\n\n\n  isElementInsideMenuStack(element) {\n    for (let el = element; el; el = el?.parentElement ?? null) {\n      if (el.getAttribute('data-cdk-menu-stack-id') === this.menuStack.id) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /** Destroy and unset the overlay reference it if exists */\n\n\n  _destroyOverlay() {\n    if (this.overlayRef) {\n      this.overlayRef.dispose();\n      this.overlayRef = null;\n    }\n  }\n  /** Gets the injector to use when creating a child menu. */\n\n\n  _getChildMenuInjector() {\n    this._childMenuInjector = this._childMenuInjector || Injector.create({\n      providers: [{\n        provide: MENU_TRIGGER,\n        useValue: this\n      }, {\n        provide: MENU_STACK,\n        useValue: this.menuStack\n      }],\n      parent: this.injector\n    });\n    return this._childMenuInjector;\n  }\n\n}\n\nCdkMenuTriggerBase.ɵfac = function CdkMenuTriggerBase_Factory(t) {\n  return new (t || CdkMenuTriggerBase)();\n};\n\nCdkMenuTriggerBase.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: CdkMenuTriggerBase,\n  hostVars: 2,\n  hostBindings: function CdkMenuTriggerBase_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      i0.ɵɵattribute(\"aria-controls\", ctx.childMenu == null ? null : ctx.childMenu.id)(\"data-cdk-menu-stack-id\", ctx.menuStack.id);\n    }\n  }\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuTriggerBase, [{\n    type: Directive,\n    args: [{\n      host: {\n        '[attr.aria-controls]': 'childMenu?.id',\n        '[attr.data-cdk-menu-stack-id]': 'menuStack.id'\n      }\n    }]\n  }], null, null);\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Throws an exception when an instance of the PointerFocusTracker is not provided.\n * @docs-private\n */\n\n\nfunction throwMissingPointerFocusTracker() {\n  throw Error('expected an instance of PointerFocusTracker to be provided');\n}\n/**\n * Throws an exception when a reference to the parent menu is not provided.\n * @docs-private\n */\n\n\nfunction throwMissingMenuReference() {\n  throw Error('expected a reference to the parent menu');\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Injection token used for an implementation of MenuAim. */\n\n\nconst MENU_AIM = new InjectionToken('cdk-menu-aim');\n/** Capture every nth mouse move event. */\n\nconst MOUSE_MOVE_SAMPLE_FREQUENCY = 3;\n/** The number of mouse move events to track. */\n\nconst NUM_POINTS = 5;\n/**\n * How long to wait before closing a sibling menu if a user stops short of the submenu they were\n * predicted to go into.\n */\n\nconst CLOSE_DELAY = 300;\n/** Calculate the slope between point a and b. */\n\nfunction getSlope(a, b) {\n  return (b.y - a.y) / (b.x - a.x);\n}\n/** Calculate the y intercept for the given point and slope. */\n\n\nfunction getYIntercept(point, slope) {\n  return point.y - slope * point.x;\n}\n/**\n * Whether the given mouse trajectory line defined by the slope and y intercept falls within the\n * submenu as defined by `submenuPoints`\n * @param submenuPoints the submenu DOMRect points.\n * @param m the slope of the trajectory line.\n * @param b the y intercept of the trajectory line.\n * @return true if any point on the line falls within the submenu.\n */\n\n\nfunction isWithinSubmenu(submenuPoints, m, b) {\n  const {\n    left,\n    right,\n    top,\n    bottom\n  } = submenuPoints; // Check for intersection with each edge of the submenu (left, right, top, bottom)\n  // by fixing one coordinate to that edge's coordinate (either x or y) and checking if the\n  // other coordinate is within bounds.\n\n  return m * left + b >= top && m * left + b <= bottom || m * right + b >= top && m * right + b <= bottom || (top - b) / m >= left && (top - b) / m <= right || (bottom - b) / m >= left && (bottom - b) / m <= right;\n}\n/**\n * TargetMenuAim predicts if a user is moving into a submenu. It calculates the\n * trajectory of the user's mouse movement in the current menu to determine if the\n * mouse is moving towards an open submenu.\n *\n * The determination is made by calculating the slope of the users last NUM_POINTS moves where each\n * pair of points determines if the trajectory line points into the submenu. It uses consensus\n * approach by checking if at least NUM_POINTS / 2 pairs determine that the user is moving towards\n * to submenu.\n */\n\n\nclass TargetMenuAim {\n  constructor() {\n    /** The Angular zone. */\n    this._ngZone = inject(NgZone);\n    /** The last NUM_POINTS mouse move events. */\n\n    this._points = [];\n    /** Emits when this service is destroyed. */\n\n    this._destroyed = new Subject();\n  }\n\n  ngOnDestroy() {\n    this._destroyed.next();\n\n    this._destroyed.complete();\n  }\n  /**\n   * Set the Menu and its PointerFocusTracker.\n   * @param menu The menu that this menu aim service controls.\n   * @param pointerTracker The `PointerFocusTracker` for the given menu.\n   */\n\n\n  initialize(menu, pointerTracker) {\n    this._menu = menu;\n    this._pointerTracker = pointerTracker;\n\n    this._subscribeToMouseMoves();\n  }\n  /**\n   * Calls the `doToggle` callback when it is deemed that the user is not moving towards\n   * the submenu.\n   * @param doToggle the function called when the user is not moving towards the submenu.\n   */\n\n\n  toggle(doToggle) {\n    // If the menu is horizontal the sub-menus open below and there is no risk of premature\n    // closing of any sub-menus therefore we automatically resolve the callback.\n    if (this._menu.orientation === 'horizontal') {\n      doToggle();\n    }\n\n    this._checkConfigured();\n\n    const siblingItemIsWaiting = !!this._timeoutId;\n    const hasPoints = this._points.length > 1;\n\n    if (hasPoints && !siblingItemIsWaiting) {\n      if (this._isMovingToSubmenu()) {\n        this._startTimeout(doToggle);\n      } else {\n        doToggle();\n      }\n    } else if (!siblingItemIsWaiting) {\n      doToggle();\n    }\n  }\n  /**\n   * Start the delayed toggle handler if one isn't running already.\n   *\n   * The delayed toggle handler executes the `doToggle` callback after some period of time iff the\n   * users mouse is on an item in the current menu.\n   *\n   * @param doToggle the function called when the user is not moving towards the submenu.\n   */\n\n\n  _startTimeout(doToggle) {\n    // If the users mouse is moving towards a submenu we don't want to immediately resolve.\n    // Wait for some period of time before determining if the previous menu should close in\n    // cases where the user may have moved towards the submenu but stopped on a sibling menu\n    // item intentionally.\n    const timeoutId = setTimeout(() => {\n      // Resolve if the user is currently moused over some element in the root menu\n      if (this._pointerTracker.activeElement && timeoutId === this._timeoutId) {\n        doToggle();\n      }\n\n      this._timeoutId = null;\n    }, CLOSE_DELAY);\n    this._timeoutId = timeoutId;\n  }\n  /** Whether the user is heading towards the open submenu. */\n\n\n  _isMovingToSubmenu() {\n    const submenuPoints = this._getSubmenuBounds();\n\n    if (!submenuPoints) {\n      return false;\n    }\n\n    let numMoving = 0;\n    const currPoint = this._points[this._points.length - 1]; // start from the second last point and calculate the slope between each point and the last\n    // point.\n\n    for (let i = this._points.length - 2; i >= 0; i--) {\n      const previous = this._points[i];\n      const slope = getSlope(currPoint, previous);\n\n      if (isWithinSubmenu(submenuPoints, slope, getYIntercept(currPoint, slope))) {\n        numMoving++;\n      }\n    }\n\n    return numMoving >= Math.floor(NUM_POINTS / 2);\n  }\n  /** Get the bounding DOMRect for the open submenu. */\n\n\n  _getSubmenuBounds() {\n    return this._pointerTracker?.previousElement?.getMenu()?.nativeElement.getBoundingClientRect();\n  }\n  /**\n   * Check if a reference to the PointerFocusTracker and menu element is provided.\n   * @throws an error if neither reference is provided.\n   */\n\n\n  _checkConfigured() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!this._pointerTracker) {\n        throwMissingPointerFocusTracker();\n      }\n\n      if (!this._menu) {\n        throwMissingMenuReference();\n      }\n    }\n  }\n  /** Subscribe to the root menus mouse move events and update the tracked mouse points. */\n\n\n  _subscribeToMouseMoves() {\n    this._ngZone.runOutsideAngular(() => {\n      fromEvent(this._menu.nativeElement, 'mousemove').pipe(filter((_, index) => index % MOUSE_MOVE_SAMPLE_FREQUENCY === 0), takeUntil(this._destroyed)).subscribe(event => {\n        this._points.push({\n          x: event.clientX,\n          y: event.clientY\n        });\n\n        if (this._points.length > NUM_POINTS) {\n          this._points.shift();\n        }\n      });\n    });\n  }\n\n}\n\nTargetMenuAim.ɵfac = function TargetMenuAim_Factory(t) {\n  return new (t || TargetMenuAim)();\n};\n\nTargetMenuAim.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: TargetMenuAim,\n  factory: TargetMenuAim.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TargetMenuAim, [{\n    type: Injectable\n  }], null, null);\n})();\n/**\n * CdkTargetMenuAim is a provider for the TargetMenuAim service. It can be added to an\n * element with either the `cdkMenu` or `cdkMenuBar` directive and child menu items.\n */\n\n\nclass CdkTargetMenuAim {}\n\nCdkTargetMenuAim.ɵfac = function CdkTargetMenuAim_Factory(t) {\n  return new (t || CdkTargetMenuAim)();\n};\n\nCdkTargetMenuAim.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: CdkTargetMenuAim,\n  selectors: [[\"\", \"cdkTargetMenuAim\", \"\"]],\n  exportAs: [\"cdkTargetMenuAim\"],\n  features: [i0.ɵɵProvidersFeature([{\n    provide: MENU_AIM,\n    useClass: TargetMenuAim\n  }])]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkTargetMenuAim, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkTargetMenuAim]',\n      exportAs: 'cdkTargetMenuAim',\n      providers: [{\n        provide: MENU_AIM,\n        useClass: TargetMenuAim\n      }]\n    }]\n  }], null, null);\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A directive that turns its host element into a trigger for a popup menu.\n * It can be combined with cdkMenuItem to create sub-menus. If the element is in a top level\n * MenuBar it will open the menu on click, or if a sibling is already opened it will open on hover.\n * If it is inside of a Menu it will open the attached Submenu on hover regardless of its sibling\n * state.\n */\n\n\nclass CdkMenuTrigger extends CdkMenuTriggerBase {\n  constructor() {\n    super();\n    /** The host element. */\n\n    this._elementRef = inject(ElementRef);\n    /** The CDK overlay service. */\n\n    this._overlay = inject(Overlay);\n    /** The Angular zone. */\n\n    this._ngZone = inject(NgZone);\n    /** The parent menu this trigger belongs to. */\n\n    this._parentMenu = inject(CDK_MENU, InjectFlags.Optional);\n    /** The menu aim service used by this menu. */\n\n    this._menuAim = inject(MENU_AIM, InjectFlags.Optional);\n    /** The directionality of the page. */\n\n    this._directionality = inject(Directionality, InjectFlags.Optional);\n\n    this._setRole();\n\n    this._registerCloseHandler();\n\n    this._subscribeToMenuStackClosed();\n\n    this._subscribeToMouseEnter();\n\n    this._subscribeToMenuStackHasFocus();\n\n    this._setType();\n  }\n  /** Toggle the attached menu. */\n\n\n  toggle() {\n    this.isOpen() ? this.close() : this.open();\n  }\n  /** Open the attached menu. */\n\n\n  open() {\n    if (!this.isOpen()) {\n      this.opened.next();\n      this.overlayRef = this.overlayRef || this._overlay.create(this._getOverlayConfig());\n      this.overlayRef.attach(this.getMenuContentPortal());\n\n      this._subscribeToOutsideClicks();\n    }\n  }\n  /** Close the opened menu. */\n\n\n  close() {\n    if (this.isOpen()) {\n      this.closed.next();\n      this.overlayRef.detach();\n    }\n\n    this._closeSiblingTriggers();\n  }\n  /**\n   * Get a reference to the rendered Menu if the Menu is open and rendered in the DOM.\n   */\n\n\n  getMenu() {\n    return this.childMenu;\n  }\n  /**\n   * Handles keyboard events for the menu item.\n   * @param event The keyboard event to handle\n   */\n\n\n  _toggleOnKeydown(event) {\n    const isParentVertical = this._parentMenu?.orientation === 'vertical';\n    const keyCode = event.keyCode;\n\n    switch (keyCode) {\n      case SPACE:\n      case ENTER:\n        if (!hasModifierKey(event)) {\n          this.toggle();\n          this.childMenu?.focusFirstItem('keyboard');\n        }\n\n        break;\n\n      case RIGHT_ARROW:\n        if (!hasModifierKey(event)) {\n          if (this._parentMenu && isParentVertical && this._directionality?.value !== 'rtl') {\n            event.preventDefault();\n            this.open();\n            this.childMenu?.focusFirstItem('keyboard');\n          }\n        }\n\n        break;\n\n      case LEFT_ARROW:\n        if (!hasModifierKey(event)) {\n          if (this._parentMenu && isParentVertical && this._directionality?.value === 'rtl') {\n            event.preventDefault();\n            this.open();\n            this.childMenu?.focusFirstItem('keyboard');\n          }\n        }\n\n        break;\n\n      case DOWN_ARROW:\n      case UP_ARROW:\n        if (!hasModifierKey(event)) {\n          if (!isParentVertical) {\n            event.preventDefault();\n            this.open();\n            keyCode === DOWN_ARROW ? this.childMenu?.focusFirstItem('keyboard') : this.childMenu?.focusLastItem('keyboard');\n          }\n        }\n\n        break;\n    }\n  }\n  /**\n   * Sets whether the trigger's menu stack has focus.\n   * @param hasFocus Whether the menu stack has focus.\n   */\n\n\n  _setHasFocus(hasFocus) {\n    if (!this._parentMenu) {\n      this.menuStack.setHasFocus(hasFocus);\n    }\n  }\n  /**\n   * Subscribe to the mouseenter events and close any sibling menu items if this element is moused\n   * into.\n   */\n\n\n  _subscribeToMouseEnter() {\n    // Closes any sibling menu items and opens the menu associated with this trigger.\n    const toggleMenus = () => this._ngZone.run(() => {\n      this._closeSiblingTriggers();\n\n      this.open();\n    });\n\n    this._ngZone.runOutsideAngular(() => {\n      fromEvent(this._elementRef.nativeElement, 'mouseenter').pipe(filter(() => !this.menuStack.isEmpty() && !this.isOpen()), takeUntil(this.destroyed)).subscribe(() => {\n        if (this._menuAim) {\n          this._menuAim.toggle(toggleMenus);\n        } else {\n          toggleMenus();\n        }\n      });\n    });\n  }\n  /** Close out any sibling menu trigger menus. */\n\n\n  _closeSiblingTriggers() {\n    if (this._parentMenu) {\n      // If nothing was removed from the stack and the last element is not the parent item\n      // that means that the parent menu is a menu bar since we don't put the menu bar on the\n      // stack\n      const isParentMenuBar = !this.menuStack.closeSubMenuOf(this._parentMenu) && this.menuStack.peek() !== this._parentMenu;\n\n      if (isParentMenuBar) {\n        this.menuStack.closeAll();\n      }\n    } else {\n      this.menuStack.closeAll();\n    }\n  }\n  /** Get the configuration object used to create the overlay. */\n\n\n  _getOverlayConfig() {\n    return new OverlayConfig({\n      positionStrategy: this._getOverlayPositionStrategy(),\n      scrollStrategy: this._overlay.scrollStrategies.reposition(),\n      direction: this._directionality || undefined\n    });\n  }\n  /** Build the position strategy for the overlay which specifies where to place the menu. */\n\n\n  _getOverlayPositionStrategy() {\n    return this._overlay.position().flexibleConnectedTo(this._elementRef).withLockedPosition().withGrowAfterOpen().withPositions(this._getOverlayPositions());\n  }\n  /** Get the preferred positions for the opened menu relative to the menu item. */\n\n\n  _getOverlayPositions() {\n    return this.menuPosition ?? (!this._parentMenu || this._parentMenu.orientation === 'horizontal' ? STANDARD_DROPDOWN_BELOW_POSITIONS : STANDARD_DROPDOWN_ADJACENT_POSITIONS);\n  }\n  /**\n   * Subscribe to the MenuStack close events if this is a standalone trigger and close out the menu\n   * this triggers when requested.\n   */\n\n\n  _registerCloseHandler() {\n    if (!this._parentMenu) {\n      this.menuStack.closed.pipe(takeUntil(this.destroyed)).subscribe(({\n        item\n      }) => {\n        if (item === this.childMenu) {\n          this.close();\n        }\n      });\n    }\n  }\n  /**\n   * Subscribe to the overlays outside pointer events stream and handle closing out the stack if a\n   * click occurs outside the menus.\n   */\n\n\n  _subscribeToOutsideClicks() {\n    if (this.overlayRef) {\n      this.overlayRef.outsidePointerEvents().pipe(filter(e => e.target != this._elementRef.nativeElement && !this._elementRef.nativeElement.contains(e.target)), takeUntil(this.stopOutsideClicksListener)).subscribe(event => {\n        if (!this.isElementInsideMenuStack(event.target)) {\n          this.menuStack.closeAll();\n        } else {\n          this._closeSiblingTriggers();\n        }\n      });\n    }\n  }\n  /** Subscribe to the MenuStack hasFocus events. */\n\n\n  _subscribeToMenuStackHasFocus() {\n    if (!this._parentMenu) {\n      this.menuStack.hasFocus.pipe(takeUntil(this.destroyed)).subscribe(hasFocus => {\n        if (!hasFocus) {\n          this.menuStack.closeAll();\n        }\n      });\n    }\n  }\n  /** Subscribe to the MenuStack closed events. */\n\n\n  _subscribeToMenuStackClosed() {\n    if (!this._parentMenu) {\n      this.menuStack.closed.subscribe(({\n        focusParentTrigger\n      }) => {\n        if (focusParentTrigger && !this.menuStack.length()) {\n          this._elementRef.nativeElement.focus();\n        }\n      });\n    }\n  }\n  /** Sets the role attribute for this trigger if needed. */\n\n\n  _setRole() {\n    // If this trigger is part of another menu, the cdkMenuItem directive will handle setting the\n    // role, otherwise this is a standalone trigger, and we should ensure it has role=\"button\".\n    if (!this._parentMenu) {\n      this._elementRef.nativeElement.setAttribute('role', 'button');\n    }\n  }\n  /** Sets thte `type` attribute of the trigger. */\n\n\n  _setType() {\n    const element = this._elementRef.nativeElement;\n\n    if (element.nodeName === 'BUTTON' && !element.getAttribute('type')) {\n      // Prevents form submissions.\n      element.setAttribute('type', 'button');\n    }\n  }\n\n}\n\nCdkMenuTrigger.ɵfac = function CdkMenuTrigger_Factory(t) {\n  return new (t || CdkMenuTrigger)();\n};\n\nCdkMenuTrigger.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: CdkMenuTrigger,\n  selectors: [[\"\", \"cdkMenuTriggerFor\", \"\"]],\n  hostAttrs: [\"aria-haspopup\", \"menu\", 1, \"cdk-menu-trigger\"],\n  hostVars: 1,\n  hostBindings: function CdkMenuTrigger_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"focusin\", function CdkMenuTrigger_focusin_HostBindingHandler() {\n        return ctx._setHasFocus(true);\n      })(\"focusout\", function CdkMenuTrigger_focusout_HostBindingHandler() {\n        return ctx._setHasFocus(false);\n      })(\"keydown\", function CdkMenuTrigger_keydown_HostBindingHandler($event) {\n        return ctx._toggleOnKeydown($event);\n      })(\"click\", function CdkMenuTrigger_click_HostBindingHandler() {\n        return ctx.toggle();\n      });\n    }\n\n    if (rf & 2) {\n      i0.ɵɵattribute(\"aria-expanded\", ctx.isOpen());\n    }\n  },\n  inputs: {\n    menuTemplateRef: [\"cdkMenuTriggerFor\", \"menuTemplateRef\"],\n    menuPosition: [\"cdkMenuPosition\", \"menuPosition\"]\n  },\n  outputs: {\n    opened: \"cdkMenuOpened\",\n    closed: \"cdkMenuClosed\"\n  },\n  exportAs: [\"cdkMenuTriggerFor\"],\n  features: [i0.ɵɵProvidersFeature([{\n    provide: MENU_TRIGGER,\n    useExisting: CdkMenuTrigger\n  }, PARENT_OR_NEW_MENU_STACK_PROVIDER]), i0.ɵɵInheritDefinitionFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuTrigger, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkMenuTriggerFor]',\n      exportAs: 'cdkMenuTriggerFor',\n      host: {\n        'class': 'cdk-menu-trigger',\n        'aria-haspopup': 'menu',\n        '[attr.aria-expanded]': 'isOpen()',\n        '(focusin)': '_setHasFocus(true)',\n        '(focusout)': '_setHasFocus(false)',\n        '(keydown)': '_toggleOnKeydown($event)',\n        '(click)': 'toggle()'\n      },\n      inputs: ['menuTemplateRef: cdkMenuTriggerFor', 'menuPosition: cdkMenuPosition'],\n      outputs: ['opened: cdkMenuOpened', 'closed: cdkMenuClosed'],\n      providers: [{\n        provide: MENU_TRIGGER,\n        useExisting: CdkMenuTrigger\n      }, PARENT_OR_NEW_MENU_STACK_PROVIDER]\n    }]\n  }], function () {\n    return [];\n  }, null);\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Directive which provides the ability for an element to be focused and navigated to using the\n * keyboard when residing in a CdkMenu, CdkMenuBar, or CdkMenuGroup. It performs user defined\n * behavior when clicked.\n */\n\n\nclass CdkMenuItem {\n  constructor() {\n    /** The directionality (text direction) of the current page. */\n    this._dir = inject(Directionality, InjectFlags.Optional);\n    /** The menu's native DOM host element. */\n\n    this._elementRef = inject(ElementRef);\n    /** The Angular zone. */\n\n    this._ngZone = inject(NgZone);\n    /** The menu aim service used by this menu. */\n\n    this._menuAim = inject(MENU_AIM, InjectFlags.Optional);\n    /** The stack of menus this menu belongs to. */\n\n    this._menuStack = inject(MENU_STACK);\n    /** The parent menu in which this menuitem resides. */\n\n    this._parentMenu = inject(CDK_MENU, InjectFlags.Optional);\n    /** Reference to the CdkMenuItemTrigger directive if one is added to the same element */\n\n    this._menuTrigger = inject(CdkMenuTrigger, InjectFlags.Optional | InjectFlags.Self);\n    this._disabled = false;\n    /**\n     * If this MenuItem is a regular MenuItem, outputs when it is triggered by a keyboard or mouse\n     * event.\n     */\n\n    this.triggered = new EventEmitter();\n    /** Whether the menu item opens a menu. */\n\n    this.hasMenu = !!this._menuTrigger;\n    /**\n     * The tabindex for this menu item managed internally and used for implementing roving a\n     * tab index.\n     */\n\n    this._tabindex = -1;\n    /** Whether the item should close the menu if triggered by the spacebar. */\n\n    this.closeOnSpacebarTrigger = true;\n    /** Emits when the menu item is destroyed. */\n\n    this.destroyed = new Subject();\n\n    this._setupMouseEnter();\n\n    this._setType();\n\n    if (this._isStandaloneItem()) {\n      this._tabindex = 0;\n    }\n  }\n  /**  Whether the CdkMenuItem is disabled - defaults to false */\n\n\n  get disabled() {\n    return this._disabled;\n  }\n\n  set disabled(value) {\n    this._disabled = coerceBooleanProperty(value);\n  }\n\n  ngOnDestroy() {\n    this.destroyed.next();\n    this.destroyed.complete();\n  }\n  /** Place focus on the element. */\n\n\n  focus() {\n    this._elementRef.nativeElement.focus();\n  }\n  /**\n   * If the menu item is not disabled and the element does not have a menu trigger attached, emit\n   * on the cdkMenuItemTriggered emitter and close all open menus.\n   * @param options Options the configure how the item is triggered\n   *   - keepOpen: specifies that the menu should be kept open after triggering the item.\n   */\n\n\n  trigger(options) {\n    const {\n      keepOpen\n    } = { ...options\n    };\n\n    if (!this.disabled && !this.hasMenu) {\n      this.triggered.next();\n\n      if (!keepOpen) {\n        this._menuStack.closeAll({\n          focusParentTrigger: true\n        });\n      }\n    }\n  }\n  /** Return true if this MenuItem has an attached menu and it is open. */\n\n\n  isMenuOpen() {\n    return !!this._menuTrigger?.isOpen();\n  }\n  /**\n   * Get a reference to the rendered Menu if the Menu is open and it is visible in the DOM.\n   * @return the menu if it is open, otherwise undefined.\n   */\n\n\n  getMenu() {\n    return this._menuTrigger?.getMenu();\n  }\n  /** Get the CdkMenuTrigger associated with this element. */\n\n\n  getMenuTrigger() {\n    return this._menuTrigger;\n  }\n  /** Get the label for this element which is required by the FocusableOption interface. */\n\n\n  getLabel() {\n    return this.typeaheadLabel || this._elementRef.nativeElement.textContent?.trim() || '';\n  }\n  /** Reset the tabindex to -1. */\n\n\n  _resetTabIndex() {\n    if (!this._isStandaloneItem()) {\n      this._tabindex = -1;\n    }\n  }\n  /**\n   * Set the tab index to 0 if not disabled and it's a focus event, or a mouse enter if this element\n   * is not in a menu bar.\n   */\n\n\n  _setTabIndex(event) {\n    if (this.disabled) {\n      return;\n    } // don't set the tabindex if there are no open sibling or parent menus\n\n\n    if (!event || !this._menuStack.isEmpty()) {\n      this._tabindex = 0;\n    }\n  }\n  /**\n   * Handles keyboard events for the menu item, specifically either triggering the user defined\n   * callback or opening/closing the current menu based on whether the left or right arrow key was\n   * pressed.\n   * @param event the keyboard event to handle\n   */\n\n\n  _onKeydown(event) {\n    switch (event.keyCode) {\n      case SPACE:\n      case ENTER:\n        if (!hasModifierKey(event)) {\n          this.trigger({\n            keepOpen: event.keyCode === SPACE && !this.closeOnSpacebarTrigger\n          });\n        }\n\n        break;\n\n      case RIGHT_ARROW:\n        if (!hasModifierKey(event)) {\n          if (this._parentMenu && this._isParentVertical()) {\n            if (this._dir?.value !== 'rtl') {\n              this._forwardArrowPressed(event);\n            } else {\n              this._backArrowPressed(event);\n            }\n          }\n        }\n\n        break;\n\n      case LEFT_ARROW:\n        if (!hasModifierKey(event)) {\n          if (this._parentMenu && this._isParentVertical()) {\n            if (this._dir?.value !== 'rtl') {\n              this._backArrowPressed(event);\n            } else {\n              this._forwardArrowPressed(event);\n            }\n          }\n        }\n\n        break;\n    }\n  }\n  /** Whether this menu item is standalone or within a menu or menu bar. */\n\n\n  _isStandaloneItem() {\n    return !this._parentMenu;\n  }\n  /**\n   * Handles the user pressing the back arrow key.\n   * @param event The keyboard event.\n   */\n\n\n  _backArrowPressed(event) {\n    const parentMenu = this._parentMenu;\n\n    if (this._menuStack.hasInlineMenu() || this._menuStack.length() > 1) {\n      event.preventDefault();\n\n      this._menuStack.close(parentMenu, {\n        focusNextOnEmpty: this._menuStack.inlineMenuOrientation() === 'horizontal' ? 1\n        /* FocusNext.previousItem */\n        : 2\n        /* FocusNext.currentItem */\n        ,\n        focusParentTrigger: true\n      });\n    }\n  }\n  /**\n   * Handles the user pressing the forward arrow key.\n   * @param event The keyboard event.\n   */\n\n\n  _forwardArrowPressed(event) {\n    if (!this.hasMenu && this._menuStack.inlineMenuOrientation() === 'horizontal') {\n      event.preventDefault();\n\n      this._menuStack.closeAll({\n        focusNextOnEmpty: 0\n        /* FocusNext.nextItem */\n        ,\n        focusParentTrigger: true\n      });\n    }\n  }\n  /**\n   * Subscribe to the mouseenter events and close any sibling menu items if this element is moused\n   * into.\n   */\n\n\n  _setupMouseEnter() {\n    if (!this._isStandaloneItem()) {\n      const closeOpenSiblings = () => this._ngZone.run(() => this._menuStack.closeSubMenuOf(this._parentMenu));\n\n      this._ngZone.runOutsideAngular(() => fromEvent(this._elementRef.nativeElement, 'mouseenter').pipe(filter(() => !this._menuStack.isEmpty() && !this.hasMenu), takeUntil(this.destroyed)).subscribe(() => {\n        if (this._menuAim) {\n          this._menuAim.toggle(closeOpenSiblings);\n        } else {\n          closeOpenSiblings();\n        }\n      }));\n    }\n  }\n  /**\n   * Return true if the enclosing parent menu is configured in a horizontal orientation, false\n   * otherwise or if no parent.\n   */\n\n\n  _isParentVertical() {\n    return this._parentMenu?.orientation === 'vertical';\n  }\n  /** Sets the `type` attribute of the menu item. */\n\n\n  _setType() {\n    const element = this._elementRef.nativeElement;\n\n    if (element.nodeName === 'BUTTON' && !element.getAttribute('type')) {\n      // Prevent form submissions.\n      element.setAttribute('type', 'button');\n    }\n  }\n\n}\n\nCdkMenuItem.ɵfac = function CdkMenuItem_Factory(t) {\n  return new (t || CdkMenuItem)();\n};\n\nCdkMenuItem.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: CdkMenuItem,\n  selectors: [[\"\", \"cdkMenuItem\", \"\"]],\n  hostAttrs: [\"role\", \"menuitem\", 1, \"cdk-menu-item\"],\n  hostVars: 2,\n  hostBindings: function CdkMenuItem_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"blur\", function CdkMenuItem_blur_HostBindingHandler() {\n        return ctx._resetTabIndex();\n      })(\"focus\", function CdkMenuItem_focus_HostBindingHandler() {\n        return ctx._setTabIndex();\n      })(\"click\", function CdkMenuItem_click_HostBindingHandler() {\n        return ctx.trigger();\n      })(\"keydown\", function CdkMenuItem_keydown_HostBindingHandler($event) {\n        return ctx._onKeydown($event);\n      });\n    }\n\n    if (rf & 2) {\n      i0.ɵɵhostProperty(\"tabindex\", ctx._tabindex);\n      i0.ɵɵattribute(\"aria-disabled\", ctx.disabled || null);\n    }\n  },\n  inputs: {\n    disabled: [\"cdkMenuItemDisabled\", \"disabled\"],\n    typeaheadLabel: [\"cdkMenuitemTypeaheadLabel\", \"typeaheadLabel\"]\n  },\n  outputs: {\n    triggered: \"cdkMenuItemTriggered\"\n  },\n  exportAs: [\"cdkMenuItem\"]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuItem, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkMenuItem]',\n      exportAs: 'cdkMenuItem',\n      host: {\n        'role': 'menuitem',\n        'class': 'cdk-menu-item',\n        '[tabindex]': '_tabindex',\n        '[attr.aria-disabled]': 'disabled || null',\n        '(blur)': '_resetTabIndex()',\n        '(focus)': '_setTabIndex()',\n        '(click)': 'trigger()',\n        '(keydown)': '_onKeydown($event)'\n      }\n    }]\n  }], function () {\n    return [];\n  }, {\n    disabled: [{\n      type: Input,\n      args: ['cdkMenuItemDisabled']\n    }],\n    typeaheadLabel: [{\n      type: Input,\n      args: ['cdkMenuitemTypeaheadLabel']\n    }],\n    triggered: [{\n      type: Output,\n      args: ['cdkMenuItemTriggered']\n    }]\n  });\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * PointerFocusTracker keeps track of the currently active item under mouse focus. It also has\n * observables which emit when the users mouse enters and leaves a tracked element.\n */\n\n\nclass PointerFocusTracker {\n  constructor(\n  /** The list of items being tracked. */\n  _items) {\n    this._items = _items;\n    /** Emits when an element is moused into. */\n\n    this.entered = this._getItemPointerEntries();\n    /** Emits when an element is moused out. */\n\n    this.exited = this._getItemPointerExits();\n    /** Emits when this is destroyed. */\n\n    this._destroyed = new Subject();\n    this.entered.subscribe(element => this.activeElement = element);\n    this.exited.subscribe(() => {\n      this.previousElement = this.activeElement;\n      this.activeElement = undefined;\n    });\n  }\n  /** Stop the managers listeners. */\n\n\n  destroy() {\n    this._destroyed.next();\n\n    this._destroyed.complete();\n  }\n  /**\n   * Gets a stream of pointer (mouse) entries into the given items.\n   * This should typically run outside the Angular zone.\n   */\n\n\n  _getItemPointerEntries() {\n    return defer(() => this._items.changes.pipe(startWith(this._items), mergeMap(list => list.map(element => fromEvent(element._elementRef.nativeElement, 'mouseenter').pipe(mapTo(element), takeUntil(this._items.changes)))), mergeAll()));\n  }\n  /**\n   * Gets a stream of pointer (mouse) exits out of the given items.\n   * This should typically run outside the Angular zone.\n   */\n\n\n  _getItemPointerExits() {\n    return defer(() => this._items.changes.pipe(startWith(this._items), mergeMap(list => list.map(element => fromEvent(element._elementRef.nativeElement, 'mouseout').pipe(mapTo(element), takeUntil(this._items.changes)))), mergeAll()));\n  }\n\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Counter used to create unique IDs for menus. */\n\n\nlet nextId$1 = 0;\n/**\n * Abstract directive that implements shared logic common to all menus.\n * This class can be extended to create custom menu types.\n */\n\nclass CdkMenuBase extends CdkMenuGroup {\n  constructor() {\n    super(...arguments);\n    /** The menu's native DOM host element. */\n\n    this.nativeElement = inject(ElementRef).nativeElement;\n    /** The Angular zone. */\n\n    this.ngZone = inject(NgZone);\n    /** The stack of menus this menu belongs to. */\n\n    this.menuStack = inject(MENU_STACK);\n    /** The menu aim service used by this menu. */\n\n    this.menuAim = inject(MENU_AIM, InjectFlags.Optional | InjectFlags.Self);\n    /** The directionality (text direction) of the current page. */\n\n    this.dir = inject(Directionality, InjectFlags.Optional);\n    /** The id of the menu's host element. */\n\n    this.id = `cdk-menu-${nextId$1++}`;\n    /** The direction items in the menu flow. */\n\n    this.orientation = 'vertical';\n    /**\n     * Whether the menu is displayed inline (i.e. always present vs a conditional popup that the\n     * user triggers with a trigger element).\n     */\n\n    this.isInline = false;\n    /** Emits when the MenuBar is destroyed. */\n\n    this.destroyed = new Subject();\n    /** Whether this menu's menu stack has focus. */\n\n    this._menuStackHasFocus = false;\n  }\n\n  ngAfterContentInit() {\n    if (!this.isInline) {\n      this.menuStack.push(this);\n    }\n\n    this._setKeyManager();\n\n    this._subscribeToMenuStackHasFocus();\n\n    this._subscribeToMenuOpen();\n\n    this._subscribeToMenuStackClosed();\n\n    this._setUpPointerTracker();\n  }\n\n  ngOnDestroy() {\n    this.destroyed.next();\n    this.destroyed.complete();\n    this.pointerTracker?.destroy();\n  }\n  /**\n   * Place focus on the first MenuItem in the menu and set the focus origin.\n   * @param focusOrigin The origin input mode of the focus event.\n   */\n\n\n  focusFirstItem(focusOrigin = 'program') {\n    this.keyManager.setFocusOrigin(focusOrigin);\n    this.keyManager.setFirstItemActive();\n  }\n  /**\n   * Place focus on the last MenuItem in the menu and set the focus origin.\n   * @param focusOrigin The origin input mode of the focus event.\n   */\n\n\n  focusLastItem(focusOrigin = 'program') {\n    this.keyManager.setFocusOrigin(focusOrigin);\n    this.keyManager.setLastItemActive();\n  }\n  /** Gets the tabindex for this menu. */\n\n\n  _getTabIndex() {\n    const tabindexIfInline = this._menuStackHasFocus ? -1 : 0;\n    return this.isInline ? tabindexIfInline : null;\n  }\n  /**\n   * Close the open menu if the current active item opened the requested MenuStackItem.\n   * @param menu The menu requested to be closed.\n   * @param options Options to configure the behavior on close.\n   *   - `focusParentTrigger` Whether to focus the parent trigger after closing the menu.\n   */\n\n\n  closeOpenMenu(menu, options) {\n    const {\n      focusParentTrigger\n    } = { ...options\n    };\n    const keyManager = this.keyManager;\n    const trigger = this.triggerItem;\n\n    if (menu === trigger?.getMenuTrigger()?.getMenu()) {\n      trigger?.getMenuTrigger()?.close(); // If the user has moused over a sibling item we want to focus the element under mouse focus\n      // not the trigger which previously opened the now closed menu.\n\n      if (focusParentTrigger) {\n        if (trigger) {\n          keyManager.setActiveItem(trigger);\n        } else {\n          keyManager.setFirstItemActive();\n        }\n      }\n    }\n  }\n  /** Setup the FocusKeyManager with the correct orientation for the menu. */\n\n\n  _setKeyManager() {\n    this.keyManager = new FocusKeyManager(this.items).withWrap().withTypeAhead().withHomeAndEnd();\n\n    if (this.orientation === 'horizontal') {\n      this.keyManager.withHorizontalOrientation(this.dir?.value || 'ltr');\n    } else {\n      this.keyManager.withVerticalOrientation();\n    }\n  }\n  /**\n   * Subscribe to the menu trigger's open events in order to track the trigger which opened the menu\n   * and stop tracking it when the menu is closed.\n   */\n\n\n  _subscribeToMenuOpen() {\n    const exitCondition = merge(this.items.changes, this.destroyed);\n    this.items.changes.pipe(startWith(this.items), mergeMap(list => list.filter(item => item.hasMenu).map(item => item.getMenuTrigger().opened.pipe(mapTo(item), takeUntil(exitCondition)))), mergeAll(), switchMap(item => {\n      this.triggerItem = item;\n      return item.getMenuTrigger().closed;\n    }), takeUntil(this.destroyed)).subscribe(() => this.triggerItem = undefined);\n  }\n  /** Subscribe to the MenuStack close events. */\n\n\n  _subscribeToMenuStackClosed() {\n    this.menuStack.closed.pipe(takeUntil(this.destroyed)).subscribe(({\n      item,\n      focusParentTrigger\n    }) => this.closeOpenMenu(item, {\n      focusParentTrigger\n    }));\n  }\n  /** Subscribe to the MenuStack hasFocus events. */\n\n\n  _subscribeToMenuStackHasFocus() {\n    if (this.isInline) {\n      this.menuStack.hasFocus.pipe(takeUntil(this.destroyed)).subscribe(hasFocus => {\n        this._menuStackHasFocus = hasFocus;\n      });\n    }\n  }\n  /**\n   * Set the PointerFocusTracker and ensure that when mouse focus changes the key manager is updated\n   * with the latest menu item under mouse focus.\n   */\n\n\n  _setUpPointerTracker() {\n    if (this.menuAim) {\n      this.ngZone.runOutsideAngular(() => {\n        this.pointerTracker = new PointerFocusTracker(this.items);\n      });\n      this.menuAim.initialize(this, this.pointerTracker);\n    }\n  }\n\n}\n\nCdkMenuBase.ɵfac = /* @__PURE__ */function () {\n  let ɵCdkMenuBase_BaseFactory;\n  return function CdkMenuBase_Factory(t) {\n    return (ɵCdkMenuBase_BaseFactory || (ɵCdkMenuBase_BaseFactory = i0.ɵɵgetInheritedFactory(CdkMenuBase)))(t || CdkMenuBase);\n  };\n}();\n\nCdkMenuBase.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: CdkMenuBase,\n  contentQueries: function CdkMenuBase_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      i0.ɵɵcontentQuery(dirIndex, CdkMenuItem, 5);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.items = _t);\n    }\n  },\n  hostAttrs: [\"role\", \"menu\"],\n  hostVars: 4,\n  hostBindings: function CdkMenuBase_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"focus\", function CdkMenuBase_focus_HostBindingHandler() {\n        return ctx.focusFirstItem();\n      })(\"focusin\", function CdkMenuBase_focusin_HostBindingHandler() {\n        return ctx.menuStack.setHasFocus(true);\n      })(\"focusout\", function CdkMenuBase_focusout_HostBindingHandler() {\n        return ctx.menuStack.setHasFocus(false);\n      });\n    }\n\n    if (rf & 2) {\n      i0.ɵɵhostProperty(\"tabindex\", ctx._getTabIndex())(\"id\", ctx.id);\n      i0.ɵɵattribute(\"aria-orientation\", ctx.orientation)(\"data-cdk-menu-stack-id\", ctx.menuStack.id);\n    }\n  },\n  inputs: {\n    id: \"id\"\n  },\n  features: [i0.ɵɵInheritDefinitionFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuBase, [{\n    type: Directive,\n    args: [{\n      host: {\n        'role': 'menu',\n        'class': '',\n        '[tabindex]': '_getTabIndex()',\n        '[id]': 'id',\n        '[attr.aria-orientation]': 'orientation',\n        '[attr.data-cdk-menu-stack-id]': 'menuStack.id',\n        '(focus)': 'focusFirstItem()',\n        '(focusin)': 'menuStack.setHasFocus(true)',\n        '(focusout)': 'menuStack.setHasFocus(false)'\n      }\n    }]\n  }], null, {\n    id: [{\n      type: Input\n    }],\n    items: [{\n      type: ContentChildren,\n      args: [CdkMenuItem, {\n        descendants: true\n      }]\n    }]\n  });\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Directive which configures the element as a Menu which should contain child elements marked as\n * CdkMenuItem or CdkMenuGroup. Sets the appropriate role and aria-attributes for a menu and\n * contains accessible keyboard and mouse handling logic.\n *\n * It also acts as a RadioGroup for elements marked with role `menuitemradio`.\n */\n\n\nclass CdkMenu extends CdkMenuBase {\n  constructor() {\n    super();\n    this._parentTrigger = inject(MENU_TRIGGER, InjectFlags.Optional);\n    /** Event emitted when the menu is closed. */\n\n    this.closed = new EventEmitter();\n    /** The direction items in the menu flow. */\n\n    this.orientation = 'vertical';\n    /** Whether the menu is displayed inline (i.e. always present vs a conditional popup that the user triggers with a trigger element). */\n\n    this.isInline = !this._parentTrigger;\n    this.destroyed.subscribe(this.closed);\n    this._parentTrigger?.registerChildMenu(this);\n  }\n\n  ngAfterContentInit() {\n    super.ngAfterContentInit();\n\n    this._subscribeToMenuStackEmptied();\n  }\n\n  ngOnDestroy() {\n    super.ngOnDestroy();\n    this.closed.complete();\n  }\n  /**\n   * Handle keyboard events for the Menu.\n   * @param event The keyboard event to be handled.\n   */\n\n\n  _handleKeyEvent(event) {\n    const keyManager = this.keyManager;\n\n    switch (event.keyCode) {\n      case LEFT_ARROW:\n      case RIGHT_ARROW:\n        if (!hasModifierKey(event)) {\n          event.preventDefault();\n          keyManager.setFocusOrigin('keyboard');\n          keyManager.onKeydown(event);\n        }\n\n        break;\n\n      case ESCAPE:\n        if (!hasModifierKey(event)) {\n          event.preventDefault();\n          this.menuStack.close(this, {\n            focusNextOnEmpty: 2\n            /* FocusNext.currentItem */\n            ,\n            focusParentTrigger: true\n          });\n        }\n\n        break;\n\n      case TAB:\n        if (!hasModifierKey(event, 'altKey', 'metaKey', 'ctrlKey')) {\n          this.menuStack.closeAll({\n            focusParentTrigger: true\n          });\n        }\n\n        break;\n\n      default:\n        keyManager.onKeydown(event);\n    }\n  }\n  /**\n   * Set focus the either the current, previous or next item based on the FocusNext event.\n   * @param focusNext The element to focus.\n   */\n\n\n  _toggleMenuFocus(focusNext) {\n    const keyManager = this.keyManager;\n\n    switch (focusNext) {\n      case 0\n      /* FocusNext.nextItem */\n      :\n        keyManager.setFocusOrigin('keyboard');\n        keyManager.setNextItemActive();\n        break;\n\n      case 1\n      /* FocusNext.previousItem */\n      :\n        keyManager.setFocusOrigin('keyboard');\n        keyManager.setPreviousItemActive();\n        break;\n\n      case 2\n      /* FocusNext.currentItem */\n      :\n        if (keyManager.activeItem) {\n          keyManager.setFocusOrigin('keyboard');\n          keyManager.setActiveItem(keyManager.activeItem);\n        }\n\n        break;\n    }\n  }\n  /** Subscribe to the MenuStack emptied events. */\n\n\n  _subscribeToMenuStackEmptied() {\n    this.menuStack.emptied.pipe(takeUntil(this.destroyed)).subscribe(event => this._toggleMenuFocus(event));\n  }\n\n}\n\nCdkMenu.ɵfac = function CdkMenu_Factory(t) {\n  return new (t || CdkMenu)();\n};\n\nCdkMenu.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: CdkMenu,\n  selectors: [[\"\", \"cdkMenu\", \"\"]],\n  hostAttrs: [\"role\", \"menu\", 1, \"cdk-menu\"],\n  hostVars: 2,\n  hostBindings: function CdkMenu_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"keydown\", function CdkMenu_keydown_HostBindingHandler($event) {\n        return ctx._handleKeyEvent($event);\n      });\n    }\n\n    if (rf & 2) {\n      i0.ɵɵclassProp(\"cdk-menu-inline\", ctx.isInline);\n    }\n  },\n  outputs: {\n    closed: \"closed\"\n  },\n  exportAs: [\"cdkMenu\"],\n  features: [i0.ɵɵProvidersFeature([{\n    provide: CdkMenuGroup,\n    useExisting: CdkMenu\n  }, {\n    provide: CDK_MENU,\n    useExisting: CdkMenu\n  }, PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER('vertical')]), i0.ɵɵInheritDefinitionFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenu, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkMenu]',\n      exportAs: 'cdkMenu',\n      host: {\n        'role': 'menu',\n        'class': 'cdk-menu',\n        '[class.cdk-menu-inline]': 'isInline',\n        '(keydown)': '_handleKeyEvent($event)'\n      },\n      providers: [{\n        provide: CdkMenuGroup,\n        useExisting: CdkMenu\n      }, {\n        provide: CDK_MENU,\n        useExisting: CdkMenu\n      }, PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER('vertical')]\n    }]\n  }], function () {\n    return [];\n  }, {\n    closed: [{\n      type: Output\n    }]\n  });\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Directive applied to an element which configures it as a MenuBar by setting the appropriate\n * role, aria attributes, and accessible keyboard and mouse handling logic. The component that\n * this directive is applied to should contain components marked with CdkMenuItem.\n *\n */\n\n\nclass CdkMenuBar extends CdkMenuBase {\n  constructor() {\n    super(...arguments);\n    /** The direction items in the menu flow. */\n\n    this.orientation = 'horizontal';\n    /** Whether the menu is displayed inline (i.e. always present vs a conditional popup that the user triggers with a trigger element). */\n\n    this.isInline = true;\n  }\n\n  ngAfterContentInit() {\n    super.ngAfterContentInit();\n\n    this._subscribeToMenuStackEmptied();\n  }\n  /**\n   * Handle keyboard events for the Menu.\n   * @param event The keyboard event to be handled.\n   */\n\n\n  _handleKeyEvent(event) {\n    const keyManager = this.keyManager;\n\n    switch (event.keyCode) {\n      case UP_ARROW:\n      case DOWN_ARROW:\n      case LEFT_ARROW:\n      case RIGHT_ARROW:\n        if (!hasModifierKey(event)) {\n          const horizontalArrows = event.keyCode === LEFT_ARROW || event.keyCode === RIGHT_ARROW; // For a horizontal menu if the left/right keys were clicked, or a vertical menu if the\n          // up/down keys were clicked: if the current menu is open, close it then focus and open the\n          // next  menu.\n\n          if (horizontalArrows) {\n            event.preventDefault();\n            const prevIsOpen = keyManager.activeItem?.isMenuOpen();\n            keyManager.activeItem?.getMenuTrigger()?.close();\n            keyManager.setFocusOrigin('keyboard');\n            keyManager.onKeydown(event);\n\n            if (prevIsOpen) {\n              keyManager.activeItem?.getMenuTrigger()?.open();\n            }\n          }\n        }\n\n        break;\n\n      case ESCAPE:\n        if (!hasModifierKey(event)) {\n          event.preventDefault();\n          keyManager.activeItem?.getMenuTrigger()?.close();\n        }\n\n        break;\n\n      case TAB:\n        if (!hasModifierKey(event, 'altKey', 'metaKey', 'ctrlKey')) {\n          keyManager.activeItem?.getMenuTrigger()?.close();\n        }\n\n        break;\n\n      default:\n        keyManager.onKeydown(event);\n    }\n  }\n  /**\n   * Set focus to either the current, previous or next item based on the FocusNext event, then\n   * open the previous or next item.\n   * @param focusNext The element to focus.\n   */\n\n\n  _toggleOpenMenu(focusNext) {\n    const keyManager = this.keyManager;\n\n    switch (focusNext) {\n      case 0\n      /* FocusNext.nextItem */\n      :\n        keyManager.setFocusOrigin('keyboard');\n        keyManager.setNextItemActive();\n        keyManager.activeItem?.getMenuTrigger()?.open();\n        break;\n\n      case 1\n      /* FocusNext.previousItem */\n      :\n        keyManager.setFocusOrigin('keyboard');\n        keyManager.setPreviousItemActive();\n        keyManager.activeItem?.getMenuTrigger()?.open();\n        break;\n\n      case 2\n      /* FocusNext.currentItem */\n      :\n        if (keyManager.activeItem) {\n          keyManager.setFocusOrigin('keyboard');\n          keyManager.setActiveItem(keyManager.activeItem);\n        }\n\n        break;\n    }\n  }\n  /** Subscribe to the MenuStack emptied events. */\n\n\n  _subscribeToMenuStackEmptied() {\n    this.menuStack?.emptied.pipe(takeUntil(this.destroyed)).subscribe(event => this._toggleOpenMenu(event));\n  }\n\n}\n\nCdkMenuBar.ɵfac = /* @__PURE__ */function () {\n  let ɵCdkMenuBar_BaseFactory;\n  return function CdkMenuBar_Factory(t) {\n    return (ɵCdkMenuBar_BaseFactory || (ɵCdkMenuBar_BaseFactory = i0.ɵɵgetInheritedFactory(CdkMenuBar)))(t || CdkMenuBar);\n  };\n}();\n\nCdkMenuBar.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: CdkMenuBar,\n  selectors: [[\"\", \"cdkMenuBar\", \"\"]],\n  hostAttrs: [\"role\", \"menubar\", 1, \"cdk-menu-bar\"],\n  hostBindings: function CdkMenuBar_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"keydown\", function CdkMenuBar_keydown_HostBindingHandler($event) {\n        return ctx._handleKeyEvent($event);\n      });\n    }\n  },\n  exportAs: [\"cdkMenuBar\"],\n  features: [i0.ɵɵProvidersFeature([{\n    provide: CdkMenuGroup,\n    useExisting: CdkMenuBar\n  }, {\n    provide: CDK_MENU,\n    useExisting: CdkMenuBar\n  }, {\n    provide: MENU_STACK,\n    useFactory: () => MenuStack.inline('horizontal')\n  }]), i0.ɵɵInheritDefinitionFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuBar, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkMenuBar]',\n      exportAs: 'cdkMenuBar',\n      host: {\n        'role': 'menubar',\n        'class': 'cdk-menu-bar',\n        '(keydown)': '_handleKeyEvent($event)'\n      },\n      providers: [{\n        provide: CdkMenuGroup,\n        useExisting: CdkMenuBar\n      }, {\n        provide: CDK_MENU,\n        useExisting: CdkMenuBar\n      }, {\n        provide: MENU_STACK,\n        useFactory: () => MenuStack.inline('horizontal')\n      }]\n    }]\n  }], null, null);\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Base class providing checked state for selectable MenuItems. */\n\n\nclass CdkMenuItemSelectable extends CdkMenuItem {\n  constructor() {\n    super(...arguments);\n    this._checked = false;\n    /** Whether the item should close the menu if triggered by the spacebar. */\n\n    this.closeOnSpacebarTrigger = false;\n  }\n  /** Whether the element is checked */\n\n\n  get checked() {\n    return this._checked;\n  }\n\n  set checked(value) {\n    this._checked = coerceBooleanProperty(value);\n  }\n\n}\n\nCdkMenuItemSelectable.ɵfac = /* @__PURE__ */function () {\n  let ɵCdkMenuItemSelectable_BaseFactory;\n  return function CdkMenuItemSelectable_Factory(t) {\n    return (ɵCdkMenuItemSelectable_BaseFactory || (ɵCdkMenuItemSelectable_BaseFactory = i0.ɵɵgetInheritedFactory(CdkMenuItemSelectable)))(t || CdkMenuItemSelectable);\n  };\n}();\n\nCdkMenuItemSelectable.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: CdkMenuItemSelectable,\n  hostVars: 2,\n  hostBindings: function CdkMenuItemSelectable_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      i0.ɵɵattribute(\"aria-checked\", !!ctx.checked)(\"aria-disabled\", ctx.disabled || null);\n    }\n  },\n  inputs: {\n    checked: [\"cdkMenuItemChecked\", \"checked\"]\n  },\n  features: [i0.ɵɵInheritDefinitionFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuItemSelectable, [{\n    type: Directive,\n    args: [{\n      host: {\n        '[attr.aria-checked]': '!!checked',\n        '[attr.aria-disabled]': 'disabled || null'\n      }\n    }]\n  }], null, {\n    checked: [{\n      type: Input,\n      args: ['cdkMenuItemChecked']\n    }]\n  });\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Counter used to set a unique id and name for a selectable item */\n\n\nlet nextId = 0;\n/**\n * A directive providing behavior for the \"menuitemradio\" ARIA role, which behaves similarly to\n * a conventional radio-button. Any sibling `CdkMenuItemRadio` instances within the same `CdkMenu`\n * or `CdkMenuGroup` comprise a radio group with unique selection enforced.\n */\n\nclass CdkMenuItemRadio extends CdkMenuItemSelectable {\n  constructor() {\n    super();\n    /** The unique selection dispatcher for this radio's `CdkMenuGroup`. */\n\n    this._selectionDispatcher = inject(UniqueSelectionDispatcher);\n    /** An ID to identify this radio item to the `UniqueSelectionDispatcher`. */\n\n    this._id = `${nextId++}`;\n\n    this._registerDispatcherListener();\n  }\n\n  ngOnDestroy() {\n    super.ngOnDestroy();\n\n    this._removeDispatcherListener();\n  }\n  /**\n   * Toggles the checked state of the radio-button.\n   * @param options Options the configure how the item is triggered\n   *   - keepOpen: specifies that the menu should be kept open after triggering the item.\n   */\n\n\n  trigger(options) {\n    super.trigger(options);\n\n    if (!this.disabled) {\n      this._selectionDispatcher.notify(this._id, '');\n    }\n  }\n  /** Configure the unique selection dispatcher listener in order to toggle the checked state  */\n\n\n  _registerDispatcherListener() {\n    this._removeDispatcherListener = this._selectionDispatcher.listen(id => {\n      this.checked = this._id === id;\n    });\n  }\n\n}\n\nCdkMenuItemRadio.ɵfac = function CdkMenuItemRadio_Factory(t) {\n  return new (t || CdkMenuItemRadio)();\n};\n\nCdkMenuItemRadio.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: CdkMenuItemRadio,\n  selectors: [[\"\", \"cdkMenuItemRadio\", \"\"]],\n  hostAttrs: [\"role\", \"menuitemradio\"],\n  hostVars: 2,\n  hostBindings: function CdkMenuItemRadio_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      i0.ɵɵclassProp(\"cdk-menu-item-radio\", true);\n    }\n  },\n  exportAs: [\"cdkMenuItemRadio\"],\n  features: [i0.ɵɵProvidersFeature([{\n    provide: CdkMenuItemSelectable,\n    useExisting: CdkMenuItemRadio\n  }, {\n    provide: CdkMenuItem,\n    useExisting: CdkMenuItemSelectable\n  }]), i0.ɵɵInheritDefinitionFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuItemRadio, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkMenuItemRadio]',\n      exportAs: 'cdkMenuItemRadio',\n      host: {\n        'role': 'menuitemradio',\n        '[class.cdk-menu-item-radio]': 'true'\n      },\n      providers: [{\n        provide: CdkMenuItemSelectable,\n        useExisting: CdkMenuItemRadio\n      }, {\n        provide: CdkMenuItem,\n        useExisting: CdkMenuItemSelectable\n      }]\n    }]\n  }], function () {\n    return [];\n  }, null);\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A directive providing behavior for the \"menuitemcheckbox\" ARIA role, which behaves similarly to a\n * conventional checkbox.\n */\n\n\nclass CdkMenuItemCheckbox extends CdkMenuItemSelectable {\n  /**\n   * Toggle the checked state of the checkbox.\n   * @param options Options the configure how the item is triggered\n   *   - keepOpen: specifies that the menu should be kept open after triggering the item.\n   */\n  trigger(options) {\n    super.trigger(options);\n\n    if (!this.disabled) {\n      this.checked = !this.checked;\n    }\n  }\n\n}\n\nCdkMenuItemCheckbox.ɵfac = /* @__PURE__ */function () {\n  let ɵCdkMenuItemCheckbox_BaseFactory;\n  return function CdkMenuItemCheckbox_Factory(t) {\n    return (ɵCdkMenuItemCheckbox_BaseFactory || (ɵCdkMenuItemCheckbox_BaseFactory = i0.ɵɵgetInheritedFactory(CdkMenuItemCheckbox)))(t || CdkMenuItemCheckbox);\n  };\n}();\n\nCdkMenuItemCheckbox.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: CdkMenuItemCheckbox,\n  selectors: [[\"\", \"cdkMenuItemCheckbox\", \"\"]],\n  hostAttrs: [\"role\", \"menuitemcheckbox\"],\n  hostVars: 2,\n  hostBindings: function CdkMenuItemCheckbox_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      i0.ɵɵclassProp(\"cdk-menu-item-checkbox\", true);\n    }\n  },\n  exportAs: [\"cdkMenuItemCheckbox\"],\n  features: [i0.ɵɵProvidersFeature([{\n    provide: CdkMenuItemSelectable,\n    useExisting: CdkMenuItemCheckbox\n  }, {\n    provide: CdkMenuItem,\n    useExisting: CdkMenuItemSelectable\n  }]), i0.ɵɵInheritDefinitionFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuItemCheckbox, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkMenuItemCheckbox]',\n      exportAs: 'cdkMenuItemCheckbox',\n      host: {\n        'role': 'menuitemcheckbox',\n        '[class.cdk-menu-item-checkbox]': 'true'\n      },\n      providers: [{\n        provide: CdkMenuItemSelectable,\n        useExisting: CdkMenuItemCheckbox\n      }, {\n        provide: CdkMenuItem,\n        useExisting: CdkMenuItemSelectable\n      }]\n    }]\n  }], null, null);\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** The preferred menu positions for the context menu. */\n\n\nconst CONTEXT_MENU_POSITIONS = STANDARD_DROPDOWN_BELOW_POSITIONS.map(position => {\n  // In cases where the first menu item in the context menu is a trigger the submenu opens on a\n  // hover event. We offset the context menu 2px by default to prevent this from occurring.\n  const offsetX = position.overlayX === 'start' ? 2 : -2;\n  const offsetY = position.overlayY === 'top' ? 2 : -2;\n  return { ...position,\n    offsetX,\n    offsetY\n  };\n});\n/** Tracks the last open context menu trigger across the entire application. */\n\nclass ContextMenuTracker {\n  /**\n   * Close the previous open context menu and set the given one as being open.\n   * @param trigger The trigger for the currently open Context Menu.\n   */\n  update(trigger) {\n    if (ContextMenuTracker._openContextMenuTrigger !== trigger) {\n      ContextMenuTracker._openContextMenuTrigger?.close();\n      ContextMenuTracker._openContextMenuTrigger = trigger;\n    }\n  }\n\n}\n\nContextMenuTracker.ɵfac = function ContextMenuTracker_Factory(t) {\n  return new (t || ContextMenuTracker)();\n};\n\nContextMenuTracker.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ContextMenuTracker,\n  factory: ContextMenuTracker.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ContextMenuTracker, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n/**\n * A directive that opens a menu when a user right-clicks within its host element.\n * It is aware of nested context menus and will trigger only the lowest level non-disabled context menu.\n */\n\n\nclass CdkContextMenuTrigger extends CdkMenuTriggerBase {\n  constructor() {\n    super();\n    /** The CDK overlay service. */\n\n    this._overlay = inject(Overlay);\n    /** The directionality of the page. */\n\n    this._directionality = inject(Directionality, InjectFlags.Optional);\n    /** The app's context menu tracking registry */\n\n    this._contextMenuTracker = inject(ContextMenuTracker);\n    this._disabled = false;\n\n    this._setMenuStackCloseListener();\n  }\n  /** Whether the context menu is disabled. */\n\n\n  get disabled() {\n    return this._disabled;\n  }\n\n  set disabled(value) {\n    this._disabled = coerceBooleanProperty(value);\n  }\n  /**\n   * Open the attached menu at the specified location.\n   * @param coordinates where to open the context menu\n   */\n\n\n  open(coordinates) {\n    this._open(coordinates, false);\n  }\n  /** Close the currently opened context menu. */\n\n\n  close() {\n    this.menuStack.closeAll();\n  }\n  /**\n   * Open the context menu and closes any previously open menus.\n   * @param event the mouse event which opens the context menu.\n   */\n\n\n  _openOnContextMenu(event) {\n    if (!this.disabled) {\n      // Prevent the native context menu from opening because we're opening a custom one.\n      event.preventDefault(); // Stop event propagation to ensure that only the closest enabled context menu opens.\n      // Otherwise, any context menus attached to containing elements would *also* open,\n      // resulting in multiple stacked context menus being displayed.\n\n      event.stopPropagation();\n\n      this._contextMenuTracker.update(this);\n\n      this._open({\n        x: event.clientX,\n        y: event.clientY\n      }, true); // A context menu can be triggered via a mouse right click or a keyboard shortcut.\n\n\n      if (event.button === 2) {\n        this.childMenu?.focusFirstItem('mouse');\n      } else if (event.button === 0) {\n        this.childMenu?.focusFirstItem('keyboard');\n      } else {\n        this.childMenu?.focusFirstItem('program');\n      }\n    }\n  }\n  /**\n   * Get the configuration object used to create the overlay.\n   * @param coordinates the location to place the opened menu\n   */\n\n\n  _getOverlayConfig(coordinates) {\n    return new OverlayConfig({\n      positionStrategy: this._getOverlayPositionStrategy(coordinates),\n      scrollStrategy: this._overlay.scrollStrategies.reposition(),\n      direction: this._directionality || undefined\n    });\n  }\n  /**\n   * Get the position strategy for the overlay which specifies where to place the menu.\n   * @param coordinates the location to place the opened menu\n   */\n\n\n  _getOverlayPositionStrategy(coordinates) {\n    return this._overlay.position().flexibleConnectedTo(coordinates).withLockedPosition().withGrowAfterOpen().withPositions(this.menuPosition ?? CONTEXT_MENU_POSITIONS);\n  }\n  /** Subscribe to the menu stack close events and close this menu when requested. */\n\n\n  _setMenuStackCloseListener() {\n    this.menuStack.closed.pipe(takeUntil(this.destroyed)).subscribe(({\n      item\n    }) => {\n      if (item === this.childMenu && this.isOpen()) {\n        this.closed.next();\n        this.overlayRef.detach();\n      }\n    });\n  }\n  /**\n   * Subscribe to the overlays outside pointer events stream and handle closing out the stack if a\n   * click occurs outside the menus.\n   * @param ignoreFirstAuxClick Whether to ignore the first auxclick event outside the menu.\n   */\n\n\n  _subscribeToOutsideClicks(ignoreFirstAuxClick) {\n    if (this.overlayRef) {\n      let outsideClicks = this.overlayRef.outsidePointerEvents(); // If the menu was triggered by the `contextmenu` event, skip the first `auxclick` event\n      // because it fires when the mouse is released on the same click that opened the menu.\n\n      if (ignoreFirstAuxClick) {\n        const [auxClicks, nonAuxClicks] = partition(outsideClicks, ({\n          type\n        }) => type === 'auxclick');\n        outsideClicks = merge(nonAuxClicks, auxClicks.pipe(skip(1)));\n      }\n\n      outsideClicks.pipe(takeUntil(this.stopOutsideClicksListener)).subscribe(event => {\n        if (!this.isElementInsideMenuStack(event.target)) {\n          this.menuStack.closeAll();\n        }\n      });\n    }\n  }\n  /**\n   * Open the attached menu at the specified location.\n   * @param coordinates where to open the context menu\n   * @param ignoreFirstOutsideAuxClick Whether to ignore the first auxclick outside the menu after opening.\n   */\n\n\n  _open(coordinates, ignoreFirstOutsideAuxClick) {\n    if (this.disabled) {\n      return;\n    }\n\n    if (this.isOpen()) {\n      // since we're moving this menu we need to close any submenus first otherwise they end up\n      // disconnected from this one.\n      this.menuStack.closeSubMenuOf(this.childMenu);\n      this.overlayRef.getConfig().positionStrategy.setOrigin(coordinates);\n      this.overlayRef.updatePosition();\n    } else {\n      this.opened.next();\n\n      if (this.overlayRef) {\n        this.overlayRef.getConfig().positionStrategy.setOrigin(coordinates);\n        this.overlayRef.updatePosition();\n      } else {\n        this.overlayRef = this._overlay.create(this._getOverlayConfig(coordinates));\n      }\n\n      this.overlayRef.attach(this.getMenuContentPortal());\n\n      this._subscribeToOutsideClicks(ignoreFirstOutsideAuxClick);\n    }\n  }\n\n}\n\nCdkContextMenuTrigger.ɵfac = function CdkContextMenuTrigger_Factory(t) {\n  return new (t || CdkContextMenuTrigger)();\n};\n\nCdkContextMenuTrigger.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: CdkContextMenuTrigger,\n  selectors: [[\"\", \"cdkContextMenuTriggerFor\", \"\"]],\n  hostVars: 1,\n  hostBindings: function CdkContextMenuTrigger_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"contextmenu\", function CdkContextMenuTrigger_contextmenu_HostBindingHandler($event) {\n        return ctx._openOnContextMenu($event);\n      });\n    }\n\n    if (rf & 2) {\n      i0.ɵɵattribute(\"data-cdk-menu-stack-id\", null);\n    }\n  },\n  inputs: {\n    menuTemplateRef: [\"cdkContextMenuTriggerFor\", \"menuTemplateRef\"],\n    menuPosition: [\"cdkContextMenuPosition\", \"menuPosition\"],\n    disabled: [\"cdkContextMenuDisabled\", \"disabled\"]\n  },\n  outputs: {\n    opened: \"cdkContextMenuOpened\",\n    closed: \"cdkContextMenuClosed\"\n  },\n  exportAs: [\"cdkContextMenuTriggerFor\"],\n  features: [i0.ɵɵProvidersFeature([{\n    provide: MENU_TRIGGER,\n    useExisting: CdkContextMenuTrigger\n  }, {\n    provide: MENU_STACK,\n    useClass: MenuStack\n  }]), i0.ɵɵInheritDefinitionFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkContextMenuTrigger, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkContextMenuTriggerFor]',\n      exportAs: 'cdkContextMenuTriggerFor',\n      host: {\n        '[attr.data-cdk-menu-stack-id]': 'null',\n        '(contextmenu)': '_openOnContextMenu($event)'\n      },\n      inputs: ['menuTemplateRef: cdkContextMenuTriggerFor', 'menuPosition: cdkContextMenuPosition'],\n      outputs: ['opened: cdkContextMenuOpened', 'closed: cdkContextMenuClosed'],\n      providers: [{\n        provide: MENU_TRIGGER,\n        useExisting: CdkContextMenuTrigger\n      }, {\n        provide: MENU_STACK,\n        useClass: MenuStack\n      }]\n    }]\n  }], function () {\n    return [];\n  }, {\n    disabled: [{\n      type: Input,\n      args: ['cdkContextMenuDisabled']\n    }]\n  });\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** The list of components and directives that should be declared and exported from this module. */\n\n\nconst EXPORTED_DECLARATIONS = [CdkMenuBar, CdkMenu, CdkMenuItem, CdkMenuItemRadio, CdkMenuItemCheckbox, CdkMenuTrigger, CdkMenuGroup, CdkContextMenuTrigger, CdkTargetMenuAim];\n/** Module that declares components and directives for the CDK menu. */\n\nclass CdkMenuModule {}\n\nCdkMenuModule.ɵfac = function CdkMenuModule_Factory(t) {\n  return new (t || CdkMenuModule)();\n};\n\nCdkMenuModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: CdkMenuModule\n});\nCdkMenuModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [OverlayModule]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuModule, [{\n    type: NgModule,\n    args: [{\n      imports: [OverlayModule],\n      exports: EXPORTED_DECLARATIONS,\n      declarations: EXPORTED_DECLARATIONS\n    }]\n  }], null, null);\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { CDK_MENU, CdkContextMenuTrigger, CdkMenu, CdkMenuBar, CdkMenuBase, CdkMenuGroup, CdkMenuItem, CdkMenuItemCheckbox, CdkMenuItemRadio, CdkMenuItemSelectable, CdkMenuModule, CdkMenuTrigger, CdkMenuTriggerBase, CdkTargetMenuAim, ContextMenuTracker, MENU_AIM, MENU_STACK, MENU_TRIGGER, MenuStack, PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER, PARENT_OR_NEW_MENU_STACK_PROVIDER, PointerFocusTracker, TargetMenuAim };","map":{"version":3,"names":["i0","Directive","InjectionToken","Optional","SkipSelf","Inject","Injectable","inject","Injector","ViewContainerRef","EventEmitter","NgZone","ElementRef","InjectFlags","Input","Output","ContentChildren","NgModule","Overlay","OverlayConfig","STANDARD_DROPDOWN_BELOW_POSITIONS","STANDARD_DROPDOWN_ADJACENT_POSITIONS","OverlayModule","UP_ARROW","hasModifierKey","DOWN_ARROW","LEFT_ARROW","RIGHT_ARROW","ENTER","SPACE","TAB","ESCAPE","startWith","debounceTime","distinctUntilChanged","filter","takeUntil","mergeMap","mapTo","mergeAll","switchMap","skip","UniqueSelectionDispatcher","Subject","merge","fromEvent","defer","partition","TemplatePortal","FocusKeyManager","coerceBooleanProperty","Directionality","CdkMenuGroup","ɵfac","ɵdir","provide","useClass","type","args","selector","exportAs","host","providers","CDK_MENU","MENU_STACK","PARENT_OR_NEW_MENU_STACK_PROVIDER","deps","useFactory","parentMenuStack","MenuStack","PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER","orientation","inline","nextId$2","constructor","id","_elements","_close","_empty","_hasFocus","closed","hasFocus","pipe","emptied","_inlineMenuOrientation","stack","push","menu","close","lastItem","options","focusNextOnEmpty","focusParentTrigger","indexOf","poppedElement","pop","next","item","isEmpty","closeSubMenuOf","removed","peek","closeAll","menuStackItem","length","hasInlineMenu","inlineMenuOrientation","setHasFocus","ɵprov","MENU_TRIGGER","CdkMenuTriggerBase","injector","viewContainerRef","menuStack","opened","overlayRef","destroyed","stopOutsideClicksListener","ngOnDestroy","_destroyOverlay","complete","isOpen","hasAttached","registerChildMenu","child","childMenu","getMenuContentPortal","hasMenuContentChanged","menuTemplateRef","_menuPortal","templateRef","undefined","_getChildMenuInjector","isElementInsideMenuStack","element","el","parentElement","getAttribute","dispose","_childMenuInjector","create","useValue","parent","throwMissingPointerFocusTracker","Error","throwMissingMenuReference","MENU_AIM","MOUSE_MOVE_SAMPLE_FREQUENCY","NUM_POINTS","CLOSE_DELAY","getSlope","a","b","y","x","getYIntercept","point","slope","isWithinSubmenu","submenuPoints","m","left","right","top","bottom","TargetMenuAim","_ngZone","_points","_destroyed","initialize","pointerTracker","_menu","_pointerTracker","_subscribeToMouseMoves","toggle","doToggle","_checkConfigured","siblingItemIsWaiting","_timeoutId","hasPoints","_isMovingToSubmenu","_startTimeout","timeoutId","setTimeout","activeElement","_getSubmenuBounds","numMoving","currPoint","i","previous","Math","floor","previousElement","getMenu","nativeElement","getBoundingClientRect","ngDevMode","runOutsideAngular","_","index","subscribe","event","clientX","clientY","shift","CdkTargetMenuAim","CdkMenuTrigger","_elementRef","_overlay","_parentMenu","_menuAim","_directionality","_setRole","_registerCloseHandler","_subscribeToMenuStackClosed","_subscribeToMouseEnter","_subscribeToMenuStackHasFocus","_setType","open","_getOverlayConfig","attach","_subscribeToOutsideClicks","detach","_closeSiblingTriggers","_toggleOnKeydown","isParentVertical","keyCode","focusFirstItem","value","preventDefault","focusLastItem","_setHasFocus","toggleMenus","run","isParentMenuBar","positionStrategy","_getOverlayPositionStrategy","scrollStrategy","scrollStrategies","reposition","direction","position","flexibleConnectedTo","withLockedPosition","withGrowAfterOpen","withPositions","_getOverlayPositions","menuPosition","outsidePointerEvents","e","target","contains","focus","setAttribute","nodeName","useExisting","inputs","outputs","CdkMenuItem","_dir","_menuStack","_menuTrigger","Self","_disabled","triggered","hasMenu","_tabindex","closeOnSpacebarTrigger","_setupMouseEnter","_isStandaloneItem","disabled","trigger","keepOpen","isMenuOpen","getMenuTrigger","getLabel","typeaheadLabel","textContent","trim","_resetTabIndex","_setTabIndex","_onKeydown","_isParentVertical","_forwardArrowPressed","_backArrowPressed","parentMenu","closeOpenSiblings","PointerFocusTracker","_items","entered","_getItemPointerEntries","exited","_getItemPointerExits","destroy","changes","list","map","nextId$1","CdkMenuBase","arguments","ngZone","menuAim","dir","isInline","_menuStackHasFocus","ngAfterContentInit","_setKeyManager","_subscribeToMenuOpen","_setUpPointerTracker","focusOrigin","keyManager","setFocusOrigin","setFirstItemActive","setLastItemActive","_getTabIndex","tabindexIfInline","closeOpenMenu","triggerItem","setActiveItem","items","withWrap","withTypeAhead","withHomeAndEnd","withHorizontalOrientation","withVerticalOrientation","exitCondition","descendants","CdkMenu","_parentTrigger","_subscribeToMenuStackEmptied","_handleKeyEvent","onKeydown","_toggleMenuFocus","focusNext","setNextItemActive","setPreviousItemActive","activeItem","CdkMenuBar","horizontalArrows","prevIsOpen","_toggleOpenMenu","CdkMenuItemSelectable","_checked","checked","nextId","CdkMenuItemRadio","_selectionDispatcher","_id","_registerDispatcherListener","_removeDispatcherListener","notify","listen","CdkMenuItemCheckbox","CONTEXT_MENU_POSITIONS","offsetX","overlayX","offsetY","overlayY","ContextMenuTracker","update","_openContextMenuTrigger","providedIn","CdkContextMenuTrigger","_contextMenuTracker","_setMenuStackCloseListener","coordinates","_open","_openOnContextMenu","stopPropagation","button","ignoreFirstAuxClick","outsideClicks","auxClicks","nonAuxClicks","ignoreFirstOutsideAuxClick","getConfig","setOrigin","updatePosition","EXPORTED_DECLARATIONS","CdkMenuModule","ɵmod","ɵinj","imports","exports","declarations"],"sources":["C:/Users/N4727144/source/WebApp/node_modules/@angular/cdk/fesm2020/menu.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Directive, InjectionToken, Optional, SkipSelf, Inject, Injectable, inject, Injector, ViewContainerRef, EventEmitter, NgZone, ElementRef, InjectFlags, Input, Output, ContentChildren, NgModule } from '@angular/core';\nimport { Overlay, OverlayConfig, STANDARD_DROPDOWN_BELOW_POSITIONS, STANDARD_DROPDOWN_ADJACENT_POSITIONS, OverlayModule } from '@angular/cdk/overlay';\nimport { UP_ARROW, hasModifierKey, DOWN_ARROW, LEFT_ARROW, RIGHT_ARROW, ENTER, SPACE, TAB, ESCAPE } from '@angular/cdk/keycodes';\nimport { startWith, debounceTime, distinctUntilChanged, filter, takeUntil, mergeMap, mapTo, mergeAll, switchMap, skip } from 'rxjs/operators';\nimport { UniqueSelectionDispatcher } from '@angular/cdk/collections';\nimport { Subject, merge, fromEvent, defer, partition } from 'rxjs';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { FocusKeyManager } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Directionality } from '@angular/cdk/bidi';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A grouping container for `CdkMenuItemRadio` instances, similar to a `role=\"radiogroup\"` element.\n */\nclass CdkMenuGroup {\n}\nCdkMenuGroup.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkMenuGroup, deps: [], target: i0.ɵɵFactoryTarget.Directive });\nCdkMenuGroup.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.0\", type: CdkMenuGroup, selector: \"[cdkMenuGroup]\", host: { attributes: { \"role\": \"group\" }, classAttribute: \"cdk-menu-group\" }, providers: [{ provide: UniqueSelectionDispatcher, useClass: UniqueSelectionDispatcher }], exportAs: [\"cdkMenuGroup\"], ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkMenuGroup, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkMenuGroup]',\n                    exportAs: 'cdkMenuGroup',\n                    host: {\n                        'role': 'group',\n                        'class': 'cdk-menu-group',\n                    },\n                    providers: [{ provide: UniqueSelectionDispatcher, useClass: UniqueSelectionDispatcher }],\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Injection token used to return classes implementing the Menu interface */\nconst CDK_MENU = new InjectionToken('cdk-menu');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Injection token used for an implementation of MenuStack. */\nconst MENU_STACK = new InjectionToken('cdk-menu-stack');\n/** Provider that provides the parent menu stack, or a new menu stack if there is no parent one. */\nconst PARENT_OR_NEW_MENU_STACK_PROVIDER = {\n    provide: MENU_STACK,\n    deps: [[new Optional(), new SkipSelf(), new Inject(MENU_STACK)]],\n    useFactory: (parentMenuStack) => parentMenuStack || new MenuStack(),\n};\n/** Provider that provides the parent menu stack, or a new inline menu stack if there is no parent one. */\nconst PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER = (orientation) => ({\n    provide: MENU_STACK,\n    deps: [[new Optional(), new SkipSelf(), new Inject(MENU_STACK)]],\n    useFactory: (parentMenuStack) => parentMenuStack || MenuStack.inline(orientation),\n});\n/** The next available menu stack ID. */\nlet nextId$2 = 0;\n/**\n * MenuStack allows subscribers to listen for close events (when a MenuStackItem is popped off\n * of the stack) in order to perform closing actions. Upon the MenuStack being empty it emits\n * from the `empty` observable specifying the next focus action which the listener should perform\n * as requested by the closer.\n */\nclass MenuStack {\n    constructor() {\n        /** The ID of this menu stack. */\n        this.id = `${nextId$2++}`;\n        /** All MenuStackItems tracked by this MenuStack. */\n        this._elements = [];\n        /** Emits the element which was popped off of the stack when requested by a closer. */\n        this._close = new Subject();\n        /** Emits once the MenuStack has become empty after popping off elements. */\n        this._empty = new Subject();\n        /** Emits whether any menu in the menu stack has focus. */\n        this._hasFocus = new Subject();\n        /** Observable which emits the MenuStackItem which has been requested to close. */\n        this.closed = this._close;\n        /** Observable which emits whether any menu in the menu stack has focus. */\n        this.hasFocus = this._hasFocus.pipe(startWith(false), debounceTime(0), distinctUntilChanged());\n        /**\n         * Observable which emits when the MenuStack is empty after popping off the last element. It\n         * emits a FocusNext event which specifies the action the closer has requested the listener\n         * perform.\n         */\n        this.emptied = this._empty;\n        /**\n         * Whether the inline menu associated with this menu stack is vertical or horizontal.\n         * `null` indicates there is no inline menu associated with this menu stack.\n         */\n        this._inlineMenuOrientation = null;\n    }\n    /** Creates a menu stack that originates from an inline menu. */\n    static inline(orientation) {\n        const stack = new MenuStack();\n        stack._inlineMenuOrientation = orientation;\n        return stack;\n    }\n    /**\n     * Adds an item to the menu stack.\n     * @param menu the MenuStackItem to put on the stack.\n     */\n    push(menu) {\n        this._elements.push(menu);\n    }\n    /**\n     * Pop items off of the stack up to and including `lastItem` and emit each on the close\n     * observable. If the stack is empty or `lastItem` is not on the stack it does nothing.\n     * @param lastItem the last item to pop off the stack.\n     * @param options Options that configure behavior on close.\n     */\n    close(lastItem, options) {\n        const { focusNextOnEmpty, focusParentTrigger } = { ...options };\n        if (this._elements.indexOf(lastItem) >= 0) {\n            let poppedElement;\n            do {\n                poppedElement = this._elements.pop();\n                this._close.next({ item: poppedElement, focusParentTrigger });\n            } while (poppedElement !== lastItem);\n            if (this.isEmpty()) {\n                this._empty.next(focusNextOnEmpty);\n            }\n        }\n    }\n    /**\n     * Pop items off of the stack up to but excluding `lastItem` and emit each on the close\n     * observable. If the stack is empty or `lastItem` is not on the stack it does nothing.\n     * @param lastItem the element which should be left on the stack\n     * @return whether or not an item was removed from the stack\n     */\n    closeSubMenuOf(lastItem) {\n        let removed = false;\n        if (this._elements.indexOf(lastItem) >= 0) {\n            removed = this.peek() !== lastItem;\n            while (this.peek() !== lastItem) {\n                this._close.next({ item: this._elements.pop() });\n            }\n        }\n        return removed;\n    }\n    /**\n     * Pop off all MenuStackItems and emit each one on the `close` observable one by one.\n     * @param options Options that configure behavior on close.\n     */\n    closeAll(options) {\n        const { focusNextOnEmpty, focusParentTrigger } = { ...options };\n        if (!this.isEmpty()) {\n            while (!this.isEmpty()) {\n                const menuStackItem = this._elements.pop();\n                if (menuStackItem) {\n                    this._close.next({ item: menuStackItem, focusParentTrigger });\n                }\n            }\n            this._empty.next(focusNextOnEmpty);\n        }\n    }\n    /** Return true if this stack is empty. */\n    isEmpty() {\n        return !this._elements.length;\n    }\n    /** Return the length of the stack. */\n    length() {\n        return this._elements.length;\n    }\n    /** Get the top most element on the stack. */\n    peek() {\n        return this._elements[this._elements.length - 1];\n    }\n    /** Whether the menu stack is associated with an inline menu. */\n    hasInlineMenu() {\n        return this._inlineMenuOrientation != null;\n    }\n    /** The orientation of the associated inline menu. */\n    inlineMenuOrientation() {\n        return this._inlineMenuOrientation;\n    }\n    /** Sets whether the menu stack contains the focused element. */\n    setHasFocus(hasFocus) {\n        this._hasFocus.next(hasFocus);\n    }\n}\nMenuStack.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: MenuStack, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nMenuStack.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: MenuStack });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: MenuStack, decorators: [{\n            type: Injectable\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Injection token used for an implementation of MenuStack. */\nconst MENU_TRIGGER = new InjectionToken('cdk-menu-trigger');\n/**\n * Abstract directive that implements shared logic common to all menu triggers.\n * This class can be extended to create custom menu trigger types.\n */\nclass CdkMenuTriggerBase {\n    constructor() {\n        /** The DI injector for this component. */\n        this.injector = inject(Injector);\n        /** The view container ref for this component */\n        this.viewContainerRef = inject(ViewContainerRef);\n        /** The menu stack in which this menu resides. */\n        this.menuStack = inject(MENU_STACK);\n        /** Emits when the attached menu is requested to open */\n        this.opened = new EventEmitter();\n        /** Emits when the attached menu is requested to close */\n        this.closed = new EventEmitter();\n        /** A reference to the overlay which manages the triggered menu */\n        this.overlayRef = null;\n        /** Emits when this trigger is destroyed. */\n        this.destroyed = new Subject();\n        /** Emits when the outside pointer events listener on the overlay should be stopped. */\n        this.stopOutsideClicksListener = merge(this.closed, this.destroyed);\n    }\n    ngOnDestroy() {\n        this._destroyOverlay();\n        this.destroyed.next();\n        this.destroyed.complete();\n    }\n    /** Whether the attached menu is open. */\n    isOpen() {\n        return !!this.overlayRef?.hasAttached();\n    }\n    /** Registers a child menu as having been opened by this trigger. */\n    registerChildMenu(child) {\n        this.childMenu = child;\n    }\n    /**\n     * Get the portal to be attached to the overlay which contains the menu. Allows for the menu\n     * content to change dynamically and be reflected in the application.\n     */\n    getMenuContentPortal() {\n        const hasMenuContentChanged = this.menuTemplateRef !== this._menuPortal?.templateRef;\n        if (this.menuTemplateRef && (!this._menuPortal || hasMenuContentChanged)) {\n            this._menuPortal = new TemplatePortal(this.menuTemplateRef, this.viewContainerRef, undefined, this._getChildMenuInjector());\n        }\n        return this._menuPortal;\n    }\n    /**\n     * Whether the given element is inside the scope of this trigger's menu stack.\n     * @param element The element to check.\n     * @return Whether the element is inside the scope of this trigger's menu stack.\n     */\n    isElementInsideMenuStack(element) {\n        for (let el = element; el; el = el?.parentElement ?? null) {\n            if (el.getAttribute('data-cdk-menu-stack-id') === this.menuStack.id) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /** Destroy and unset the overlay reference it if exists */\n    _destroyOverlay() {\n        if (this.overlayRef) {\n            this.overlayRef.dispose();\n            this.overlayRef = null;\n        }\n    }\n    /** Gets the injector to use when creating a child menu. */\n    _getChildMenuInjector() {\n        this._childMenuInjector =\n            this._childMenuInjector ||\n                Injector.create({\n                    providers: [\n                        { provide: MENU_TRIGGER, useValue: this },\n                        { provide: MENU_STACK, useValue: this.menuStack },\n                    ],\n                    parent: this.injector,\n                });\n        return this._childMenuInjector;\n    }\n}\nCdkMenuTriggerBase.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkMenuTriggerBase, deps: [], target: i0.ɵɵFactoryTarget.Directive });\nCdkMenuTriggerBase.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.0\", type: CdkMenuTriggerBase, host: { properties: { \"attr.aria-controls\": \"childMenu?.id\", \"attr.data-cdk-menu-stack-id\": \"menuStack.id\" } }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkMenuTriggerBase, decorators: [{\n            type: Directive,\n            args: [{\n                    host: {\n                        '[attr.aria-controls]': 'childMenu?.id',\n                        '[attr.data-cdk-menu-stack-id]': 'menuStack.id',\n                    },\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Throws an exception when an instance of the PointerFocusTracker is not provided.\n * @docs-private\n */\nfunction throwMissingPointerFocusTracker() {\n    throw Error('expected an instance of PointerFocusTracker to be provided');\n}\n/**\n * Throws an exception when a reference to the parent menu is not provided.\n * @docs-private\n */\nfunction throwMissingMenuReference() {\n    throw Error('expected a reference to the parent menu');\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Injection token used for an implementation of MenuAim. */\nconst MENU_AIM = new InjectionToken('cdk-menu-aim');\n/** Capture every nth mouse move event. */\nconst MOUSE_MOVE_SAMPLE_FREQUENCY = 3;\n/** The number of mouse move events to track. */\nconst NUM_POINTS = 5;\n/**\n * How long to wait before closing a sibling menu if a user stops short of the submenu they were\n * predicted to go into.\n */\nconst CLOSE_DELAY = 300;\n/** Calculate the slope between point a and b. */\nfunction getSlope(a, b) {\n    return (b.y - a.y) / (b.x - a.x);\n}\n/** Calculate the y intercept for the given point and slope. */\nfunction getYIntercept(point, slope) {\n    return point.y - slope * point.x;\n}\n/**\n * Whether the given mouse trajectory line defined by the slope and y intercept falls within the\n * submenu as defined by `submenuPoints`\n * @param submenuPoints the submenu DOMRect points.\n * @param m the slope of the trajectory line.\n * @param b the y intercept of the trajectory line.\n * @return true if any point on the line falls within the submenu.\n */\nfunction isWithinSubmenu(submenuPoints, m, b) {\n    const { left, right, top, bottom } = submenuPoints;\n    // Check for intersection with each edge of the submenu (left, right, top, bottom)\n    // by fixing one coordinate to that edge's coordinate (either x or y) and checking if the\n    // other coordinate is within bounds.\n    return ((m * left + b >= top && m * left + b <= bottom) ||\n        (m * right + b >= top && m * right + b <= bottom) ||\n        ((top - b) / m >= left && (top - b) / m <= right) ||\n        ((bottom - b) / m >= left && (bottom - b) / m <= right));\n}\n/**\n * TargetMenuAim predicts if a user is moving into a submenu. It calculates the\n * trajectory of the user's mouse movement in the current menu to determine if the\n * mouse is moving towards an open submenu.\n *\n * The determination is made by calculating the slope of the users last NUM_POINTS moves where each\n * pair of points determines if the trajectory line points into the submenu. It uses consensus\n * approach by checking if at least NUM_POINTS / 2 pairs determine that the user is moving towards\n * to submenu.\n */\nclass TargetMenuAim {\n    constructor() {\n        /** The Angular zone. */\n        this._ngZone = inject(NgZone);\n        /** The last NUM_POINTS mouse move events. */\n        this._points = [];\n        /** Emits when this service is destroyed. */\n        this._destroyed = new Subject();\n    }\n    ngOnDestroy() {\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /**\n     * Set the Menu and its PointerFocusTracker.\n     * @param menu The menu that this menu aim service controls.\n     * @param pointerTracker The `PointerFocusTracker` for the given menu.\n     */\n    initialize(menu, pointerTracker) {\n        this._menu = menu;\n        this._pointerTracker = pointerTracker;\n        this._subscribeToMouseMoves();\n    }\n    /**\n     * Calls the `doToggle` callback when it is deemed that the user is not moving towards\n     * the submenu.\n     * @param doToggle the function called when the user is not moving towards the submenu.\n     */\n    toggle(doToggle) {\n        // If the menu is horizontal the sub-menus open below and there is no risk of premature\n        // closing of any sub-menus therefore we automatically resolve the callback.\n        if (this._menu.orientation === 'horizontal') {\n            doToggle();\n        }\n        this._checkConfigured();\n        const siblingItemIsWaiting = !!this._timeoutId;\n        const hasPoints = this._points.length > 1;\n        if (hasPoints && !siblingItemIsWaiting) {\n            if (this._isMovingToSubmenu()) {\n                this._startTimeout(doToggle);\n            }\n            else {\n                doToggle();\n            }\n        }\n        else if (!siblingItemIsWaiting) {\n            doToggle();\n        }\n    }\n    /**\n     * Start the delayed toggle handler if one isn't running already.\n     *\n     * The delayed toggle handler executes the `doToggle` callback after some period of time iff the\n     * users mouse is on an item in the current menu.\n     *\n     * @param doToggle the function called when the user is not moving towards the submenu.\n     */\n    _startTimeout(doToggle) {\n        // If the users mouse is moving towards a submenu we don't want to immediately resolve.\n        // Wait for some period of time before determining if the previous menu should close in\n        // cases where the user may have moved towards the submenu but stopped on a sibling menu\n        // item intentionally.\n        const timeoutId = setTimeout(() => {\n            // Resolve if the user is currently moused over some element in the root menu\n            if (this._pointerTracker.activeElement && timeoutId === this._timeoutId) {\n                doToggle();\n            }\n            this._timeoutId = null;\n        }, CLOSE_DELAY);\n        this._timeoutId = timeoutId;\n    }\n    /** Whether the user is heading towards the open submenu. */\n    _isMovingToSubmenu() {\n        const submenuPoints = this._getSubmenuBounds();\n        if (!submenuPoints) {\n            return false;\n        }\n        let numMoving = 0;\n        const currPoint = this._points[this._points.length - 1];\n        // start from the second last point and calculate the slope between each point and the last\n        // point.\n        for (let i = this._points.length - 2; i >= 0; i--) {\n            const previous = this._points[i];\n            const slope = getSlope(currPoint, previous);\n            if (isWithinSubmenu(submenuPoints, slope, getYIntercept(currPoint, slope))) {\n                numMoving++;\n            }\n        }\n        return numMoving >= Math.floor(NUM_POINTS / 2);\n    }\n    /** Get the bounding DOMRect for the open submenu. */\n    _getSubmenuBounds() {\n        return this._pointerTracker?.previousElement?.getMenu()?.nativeElement.getBoundingClientRect();\n    }\n    /**\n     * Check if a reference to the PointerFocusTracker and menu element is provided.\n     * @throws an error if neither reference is provided.\n     */\n    _checkConfigured() {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            if (!this._pointerTracker) {\n                throwMissingPointerFocusTracker();\n            }\n            if (!this._menu) {\n                throwMissingMenuReference();\n            }\n        }\n    }\n    /** Subscribe to the root menus mouse move events and update the tracked mouse points. */\n    _subscribeToMouseMoves() {\n        this._ngZone.runOutsideAngular(() => {\n            fromEvent(this._menu.nativeElement, 'mousemove')\n                .pipe(filter((_, index) => index % MOUSE_MOVE_SAMPLE_FREQUENCY === 0), takeUntil(this._destroyed))\n                .subscribe((event) => {\n                this._points.push({ x: event.clientX, y: event.clientY });\n                if (this._points.length > NUM_POINTS) {\n                    this._points.shift();\n                }\n            });\n        });\n    }\n}\nTargetMenuAim.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: TargetMenuAim, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nTargetMenuAim.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: TargetMenuAim });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: TargetMenuAim, decorators: [{\n            type: Injectable\n        }] });\n/**\n * CdkTargetMenuAim is a provider for the TargetMenuAim service. It can be added to an\n * element with either the `cdkMenu` or `cdkMenuBar` directive and child menu items.\n */\nclass CdkTargetMenuAim {\n}\nCdkTargetMenuAim.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkTargetMenuAim, deps: [], target: i0.ɵɵFactoryTarget.Directive });\nCdkTargetMenuAim.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.0\", type: CdkTargetMenuAim, selector: \"[cdkTargetMenuAim]\", providers: [{ provide: MENU_AIM, useClass: TargetMenuAim }], exportAs: [\"cdkTargetMenuAim\"], ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkTargetMenuAim, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkTargetMenuAim]',\n                    exportAs: 'cdkTargetMenuAim',\n                    providers: [{ provide: MENU_AIM, useClass: TargetMenuAim }],\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A directive that turns its host element into a trigger for a popup menu.\n * It can be combined with cdkMenuItem to create sub-menus. If the element is in a top level\n * MenuBar it will open the menu on click, or if a sibling is already opened it will open on hover.\n * If it is inside of a Menu it will open the attached Submenu on hover regardless of its sibling\n * state.\n */\nclass CdkMenuTrigger extends CdkMenuTriggerBase {\n    constructor() {\n        super();\n        /** The host element. */\n        this._elementRef = inject(ElementRef);\n        /** The CDK overlay service. */\n        this._overlay = inject(Overlay);\n        /** The Angular zone. */\n        this._ngZone = inject(NgZone);\n        /** The parent menu this trigger belongs to. */\n        this._parentMenu = inject(CDK_MENU, InjectFlags.Optional);\n        /** The menu aim service used by this menu. */\n        this._menuAim = inject(MENU_AIM, InjectFlags.Optional);\n        /** The directionality of the page. */\n        this._directionality = inject(Directionality, InjectFlags.Optional);\n        this._setRole();\n        this._registerCloseHandler();\n        this._subscribeToMenuStackClosed();\n        this._subscribeToMouseEnter();\n        this._subscribeToMenuStackHasFocus();\n        this._setType();\n    }\n    /** Toggle the attached menu. */\n    toggle() {\n        this.isOpen() ? this.close() : this.open();\n    }\n    /** Open the attached menu. */\n    open() {\n        if (!this.isOpen()) {\n            this.opened.next();\n            this.overlayRef = this.overlayRef || this._overlay.create(this._getOverlayConfig());\n            this.overlayRef.attach(this.getMenuContentPortal());\n            this._subscribeToOutsideClicks();\n        }\n    }\n    /** Close the opened menu. */\n    close() {\n        if (this.isOpen()) {\n            this.closed.next();\n            this.overlayRef.detach();\n        }\n        this._closeSiblingTriggers();\n    }\n    /**\n     * Get a reference to the rendered Menu if the Menu is open and rendered in the DOM.\n     */\n    getMenu() {\n        return this.childMenu;\n    }\n    /**\n     * Handles keyboard events for the menu item.\n     * @param event The keyboard event to handle\n     */\n    _toggleOnKeydown(event) {\n        const isParentVertical = this._parentMenu?.orientation === 'vertical';\n        const keyCode = event.keyCode;\n        switch (keyCode) {\n            case SPACE:\n            case ENTER:\n                if (!hasModifierKey(event)) {\n                    this.toggle();\n                    this.childMenu?.focusFirstItem('keyboard');\n                }\n                break;\n            case RIGHT_ARROW:\n                if (!hasModifierKey(event)) {\n                    if (this._parentMenu && isParentVertical && this._directionality?.value !== 'rtl') {\n                        event.preventDefault();\n                        this.open();\n                        this.childMenu?.focusFirstItem('keyboard');\n                    }\n                }\n                break;\n            case LEFT_ARROW:\n                if (!hasModifierKey(event)) {\n                    if (this._parentMenu && isParentVertical && this._directionality?.value === 'rtl') {\n                        event.preventDefault();\n                        this.open();\n                        this.childMenu?.focusFirstItem('keyboard');\n                    }\n                }\n                break;\n            case DOWN_ARROW:\n            case UP_ARROW:\n                if (!hasModifierKey(event)) {\n                    if (!isParentVertical) {\n                        event.preventDefault();\n                        this.open();\n                        keyCode === DOWN_ARROW\n                            ? this.childMenu?.focusFirstItem('keyboard')\n                            : this.childMenu?.focusLastItem('keyboard');\n                    }\n                }\n                break;\n        }\n    }\n    /**\n     * Sets whether the trigger's menu stack has focus.\n     * @param hasFocus Whether the menu stack has focus.\n     */\n    _setHasFocus(hasFocus) {\n        if (!this._parentMenu) {\n            this.menuStack.setHasFocus(hasFocus);\n        }\n    }\n    /**\n     * Subscribe to the mouseenter events and close any sibling menu items if this element is moused\n     * into.\n     */\n    _subscribeToMouseEnter() {\n        // Closes any sibling menu items and opens the menu associated with this trigger.\n        const toggleMenus = () => this._ngZone.run(() => {\n            this._closeSiblingTriggers();\n            this.open();\n        });\n        this._ngZone.runOutsideAngular(() => {\n            fromEvent(this._elementRef.nativeElement, 'mouseenter')\n                .pipe(filter(() => !this.menuStack.isEmpty() && !this.isOpen()), takeUntil(this.destroyed))\n                .subscribe(() => {\n                if (this._menuAim) {\n                    this._menuAim.toggle(toggleMenus);\n                }\n                else {\n                    toggleMenus();\n                }\n            });\n        });\n    }\n    /** Close out any sibling menu trigger menus. */\n    _closeSiblingTriggers() {\n        if (this._parentMenu) {\n            // If nothing was removed from the stack and the last element is not the parent item\n            // that means that the parent menu is a menu bar since we don't put the menu bar on the\n            // stack\n            const isParentMenuBar = !this.menuStack.closeSubMenuOf(this._parentMenu) &&\n                this.menuStack.peek() !== this._parentMenu;\n            if (isParentMenuBar) {\n                this.menuStack.closeAll();\n            }\n        }\n        else {\n            this.menuStack.closeAll();\n        }\n    }\n    /** Get the configuration object used to create the overlay. */\n    _getOverlayConfig() {\n        return new OverlayConfig({\n            positionStrategy: this._getOverlayPositionStrategy(),\n            scrollStrategy: this._overlay.scrollStrategies.reposition(),\n            direction: this._directionality || undefined,\n        });\n    }\n    /** Build the position strategy for the overlay which specifies where to place the menu. */\n    _getOverlayPositionStrategy() {\n        return this._overlay\n            .position()\n            .flexibleConnectedTo(this._elementRef)\n            .withLockedPosition()\n            .withGrowAfterOpen()\n            .withPositions(this._getOverlayPositions());\n    }\n    /** Get the preferred positions for the opened menu relative to the menu item. */\n    _getOverlayPositions() {\n        return (this.menuPosition ??\n            (!this._parentMenu || this._parentMenu.orientation === 'horizontal'\n                ? STANDARD_DROPDOWN_BELOW_POSITIONS\n                : STANDARD_DROPDOWN_ADJACENT_POSITIONS));\n    }\n    /**\n     * Subscribe to the MenuStack close events if this is a standalone trigger and close out the menu\n     * this triggers when requested.\n     */\n    _registerCloseHandler() {\n        if (!this._parentMenu) {\n            this.menuStack.closed.pipe(takeUntil(this.destroyed)).subscribe(({ item }) => {\n                if (item === this.childMenu) {\n                    this.close();\n                }\n            });\n        }\n    }\n    /**\n     * Subscribe to the overlays outside pointer events stream and handle closing out the stack if a\n     * click occurs outside the menus.\n     */\n    _subscribeToOutsideClicks() {\n        if (this.overlayRef) {\n            this.overlayRef\n                .outsidePointerEvents()\n                .pipe(filter(e => e.target != this._elementRef.nativeElement &&\n                !this._elementRef.nativeElement.contains(e.target)), takeUntil(this.stopOutsideClicksListener))\n                .subscribe(event => {\n                if (!this.isElementInsideMenuStack(event.target)) {\n                    this.menuStack.closeAll();\n                }\n                else {\n                    this._closeSiblingTriggers();\n                }\n            });\n        }\n    }\n    /** Subscribe to the MenuStack hasFocus events. */\n    _subscribeToMenuStackHasFocus() {\n        if (!this._parentMenu) {\n            this.menuStack.hasFocus.pipe(takeUntil(this.destroyed)).subscribe(hasFocus => {\n                if (!hasFocus) {\n                    this.menuStack.closeAll();\n                }\n            });\n        }\n    }\n    /** Subscribe to the MenuStack closed events. */\n    _subscribeToMenuStackClosed() {\n        if (!this._parentMenu) {\n            this.menuStack.closed.subscribe(({ focusParentTrigger }) => {\n                if (focusParentTrigger && !this.menuStack.length()) {\n                    this._elementRef.nativeElement.focus();\n                }\n            });\n        }\n    }\n    /** Sets the role attribute for this trigger if needed. */\n    _setRole() {\n        // If this trigger is part of another menu, the cdkMenuItem directive will handle setting the\n        // role, otherwise this is a standalone trigger, and we should ensure it has role=\"button\".\n        if (!this._parentMenu) {\n            this._elementRef.nativeElement.setAttribute('role', 'button');\n        }\n    }\n    /** Sets thte `type` attribute of the trigger. */\n    _setType() {\n        const element = this._elementRef.nativeElement;\n        if (element.nodeName === 'BUTTON' && !element.getAttribute('type')) {\n            // Prevents form submissions.\n            element.setAttribute('type', 'button');\n        }\n    }\n}\nCdkMenuTrigger.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkMenuTrigger, deps: [], target: i0.ɵɵFactoryTarget.Directive });\nCdkMenuTrigger.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.0\", type: CdkMenuTrigger, selector: \"[cdkMenuTriggerFor]\", inputs: { menuTemplateRef: [\"cdkMenuTriggerFor\", \"menuTemplateRef\"], menuPosition: [\"cdkMenuPosition\", \"menuPosition\"] }, outputs: { opened: \"cdkMenuOpened\", closed: \"cdkMenuClosed\" }, host: { attributes: { \"aria-haspopup\": \"menu\" }, listeners: { \"focusin\": \"_setHasFocus(true)\", \"focusout\": \"_setHasFocus(false)\", \"keydown\": \"_toggleOnKeydown($event)\", \"click\": \"toggle()\" }, properties: { \"attr.aria-expanded\": \"isOpen()\" }, classAttribute: \"cdk-menu-trigger\" }, providers: [\n        { provide: MENU_TRIGGER, useExisting: CdkMenuTrigger },\n        PARENT_OR_NEW_MENU_STACK_PROVIDER,\n    ], exportAs: [\"cdkMenuTriggerFor\"], usesInheritance: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkMenuTrigger, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkMenuTriggerFor]',\n                    exportAs: 'cdkMenuTriggerFor',\n                    host: {\n                        'class': 'cdk-menu-trigger',\n                        'aria-haspopup': 'menu',\n                        '[attr.aria-expanded]': 'isOpen()',\n                        '(focusin)': '_setHasFocus(true)',\n                        '(focusout)': '_setHasFocus(false)',\n                        '(keydown)': '_toggleOnKeydown($event)',\n                        '(click)': 'toggle()',\n                    },\n                    inputs: ['menuTemplateRef: cdkMenuTriggerFor', 'menuPosition: cdkMenuPosition'],\n                    outputs: ['opened: cdkMenuOpened', 'closed: cdkMenuClosed'],\n                    providers: [\n                        { provide: MENU_TRIGGER, useExisting: CdkMenuTrigger },\n                        PARENT_OR_NEW_MENU_STACK_PROVIDER,\n                    ],\n                }]\n        }], ctorParameters: function () { return []; } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Directive which provides the ability for an element to be focused and navigated to using the\n * keyboard when residing in a CdkMenu, CdkMenuBar, or CdkMenuGroup. It performs user defined\n * behavior when clicked.\n */\nclass CdkMenuItem {\n    constructor() {\n        /** The directionality (text direction) of the current page. */\n        this._dir = inject(Directionality, InjectFlags.Optional);\n        /** The menu's native DOM host element. */\n        this._elementRef = inject(ElementRef);\n        /** The Angular zone. */\n        this._ngZone = inject(NgZone);\n        /** The menu aim service used by this menu. */\n        this._menuAim = inject(MENU_AIM, InjectFlags.Optional);\n        /** The stack of menus this menu belongs to. */\n        this._menuStack = inject(MENU_STACK);\n        /** The parent menu in which this menuitem resides. */\n        this._parentMenu = inject(CDK_MENU, InjectFlags.Optional);\n        /** Reference to the CdkMenuItemTrigger directive if one is added to the same element */\n        this._menuTrigger = inject(CdkMenuTrigger, InjectFlags.Optional | InjectFlags.Self);\n        this._disabled = false;\n        /**\n         * If this MenuItem is a regular MenuItem, outputs when it is triggered by a keyboard or mouse\n         * event.\n         */\n        this.triggered = new EventEmitter();\n        /** Whether the menu item opens a menu. */\n        this.hasMenu = !!this._menuTrigger;\n        /**\n         * The tabindex for this menu item managed internally and used for implementing roving a\n         * tab index.\n         */\n        this._tabindex = -1;\n        /** Whether the item should close the menu if triggered by the spacebar. */\n        this.closeOnSpacebarTrigger = true;\n        /** Emits when the menu item is destroyed. */\n        this.destroyed = new Subject();\n        this._setupMouseEnter();\n        this._setType();\n        if (this._isStandaloneItem()) {\n            this._tabindex = 0;\n        }\n    }\n    /**  Whether the CdkMenuItem is disabled - defaults to false */\n    get disabled() {\n        return this._disabled;\n    }\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n    }\n    ngOnDestroy() {\n        this.destroyed.next();\n        this.destroyed.complete();\n    }\n    /** Place focus on the element. */\n    focus() {\n        this._elementRef.nativeElement.focus();\n    }\n    /**\n     * If the menu item is not disabled and the element does not have a menu trigger attached, emit\n     * on the cdkMenuItemTriggered emitter and close all open menus.\n     * @param options Options the configure how the item is triggered\n     *   - keepOpen: specifies that the menu should be kept open after triggering the item.\n     */\n    trigger(options) {\n        const { keepOpen } = { ...options };\n        if (!this.disabled && !this.hasMenu) {\n            this.triggered.next();\n            if (!keepOpen) {\n                this._menuStack.closeAll({ focusParentTrigger: true });\n            }\n        }\n    }\n    /** Return true if this MenuItem has an attached menu and it is open. */\n    isMenuOpen() {\n        return !!this._menuTrigger?.isOpen();\n    }\n    /**\n     * Get a reference to the rendered Menu if the Menu is open and it is visible in the DOM.\n     * @return the menu if it is open, otherwise undefined.\n     */\n    getMenu() {\n        return this._menuTrigger?.getMenu();\n    }\n    /** Get the CdkMenuTrigger associated with this element. */\n    getMenuTrigger() {\n        return this._menuTrigger;\n    }\n    /** Get the label for this element which is required by the FocusableOption interface. */\n    getLabel() {\n        return this.typeaheadLabel || this._elementRef.nativeElement.textContent?.trim() || '';\n    }\n    /** Reset the tabindex to -1. */\n    _resetTabIndex() {\n        if (!this._isStandaloneItem()) {\n            this._tabindex = -1;\n        }\n    }\n    /**\n     * Set the tab index to 0 if not disabled and it's a focus event, or a mouse enter if this element\n     * is not in a menu bar.\n     */\n    _setTabIndex(event) {\n        if (this.disabled) {\n            return;\n        }\n        // don't set the tabindex if there are no open sibling or parent menus\n        if (!event || !this._menuStack.isEmpty()) {\n            this._tabindex = 0;\n        }\n    }\n    /**\n     * Handles keyboard events for the menu item, specifically either triggering the user defined\n     * callback or opening/closing the current menu based on whether the left or right arrow key was\n     * pressed.\n     * @param event the keyboard event to handle\n     */\n    _onKeydown(event) {\n        switch (event.keyCode) {\n            case SPACE:\n            case ENTER:\n                if (!hasModifierKey(event)) {\n                    this.trigger({ keepOpen: event.keyCode === SPACE && !this.closeOnSpacebarTrigger });\n                }\n                break;\n            case RIGHT_ARROW:\n                if (!hasModifierKey(event)) {\n                    if (this._parentMenu && this._isParentVertical()) {\n                        if (this._dir?.value !== 'rtl') {\n                            this._forwardArrowPressed(event);\n                        }\n                        else {\n                            this._backArrowPressed(event);\n                        }\n                    }\n                }\n                break;\n            case LEFT_ARROW:\n                if (!hasModifierKey(event)) {\n                    if (this._parentMenu && this._isParentVertical()) {\n                        if (this._dir?.value !== 'rtl') {\n                            this._backArrowPressed(event);\n                        }\n                        else {\n                            this._forwardArrowPressed(event);\n                        }\n                    }\n                }\n                break;\n        }\n    }\n    /** Whether this menu item is standalone or within a menu or menu bar. */\n    _isStandaloneItem() {\n        return !this._parentMenu;\n    }\n    /**\n     * Handles the user pressing the back arrow key.\n     * @param event The keyboard event.\n     */\n    _backArrowPressed(event) {\n        const parentMenu = this._parentMenu;\n        if (this._menuStack.hasInlineMenu() || this._menuStack.length() > 1) {\n            event.preventDefault();\n            this._menuStack.close(parentMenu, {\n                focusNextOnEmpty: this._menuStack.inlineMenuOrientation() === 'horizontal'\n                    ? 1 /* FocusNext.previousItem */\n                    : 2 /* FocusNext.currentItem */,\n                focusParentTrigger: true,\n            });\n        }\n    }\n    /**\n     * Handles the user pressing the forward arrow key.\n     * @param event The keyboard event.\n     */\n    _forwardArrowPressed(event) {\n        if (!this.hasMenu && this._menuStack.inlineMenuOrientation() === 'horizontal') {\n            event.preventDefault();\n            this._menuStack.closeAll({\n                focusNextOnEmpty: 0 /* FocusNext.nextItem */,\n                focusParentTrigger: true,\n            });\n        }\n    }\n    /**\n     * Subscribe to the mouseenter events and close any sibling menu items if this element is moused\n     * into.\n     */\n    _setupMouseEnter() {\n        if (!this._isStandaloneItem()) {\n            const closeOpenSiblings = () => this._ngZone.run(() => this._menuStack.closeSubMenuOf(this._parentMenu));\n            this._ngZone.runOutsideAngular(() => fromEvent(this._elementRef.nativeElement, 'mouseenter')\n                .pipe(filter(() => !this._menuStack.isEmpty() && !this.hasMenu), takeUntil(this.destroyed))\n                .subscribe(() => {\n                if (this._menuAim) {\n                    this._menuAim.toggle(closeOpenSiblings);\n                }\n                else {\n                    closeOpenSiblings();\n                }\n            }));\n        }\n    }\n    /**\n     * Return true if the enclosing parent menu is configured in a horizontal orientation, false\n     * otherwise or if no parent.\n     */\n    _isParentVertical() {\n        return this._parentMenu?.orientation === 'vertical';\n    }\n    /** Sets the `type` attribute of the menu item. */\n    _setType() {\n        const element = this._elementRef.nativeElement;\n        if (element.nodeName === 'BUTTON' && !element.getAttribute('type')) {\n            // Prevent form submissions.\n            element.setAttribute('type', 'button');\n        }\n    }\n}\nCdkMenuItem.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkMenuItem, deps: [], target: i0.ɵɵFactoryTarget.Directive });\nCdkMenuItem.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.0\", type: CdkMenuItem, selector: \"[cdkMenuItem]\", inputs: { disabled: [\"cdkMenuItemDisabled\", \"disabled\"], typeaheadLabel: [\"cdkMenuitemTypeaheadLabel\", \"typeaheadLabel\"] }, outputs: { triggered: \"cdkMenuItemTriggered\" }, host: { attributes: { \"role\": \"menuitem\" }, listeners: { \"blur\": \"_resetTabIndex()\", \"focus\": \"_setTabIndex()\", \"click\": \"trigger()\", \"keydown\": \"_onKeydown($event)\" }, properties: { \"tabindex\": \"_tabindex\", \"attr.aria-disabled\": \"disabled || null\" }, classAttribute: \"cdk-menu-item\" }, exportAs: [\"cdkMenuItem\"], ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkMenuItem, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkMenuItem]',\n                    exportAs: 'cdkMenuItem',\n                    host: {\n                        'role': 'menuitem',\n                        'class': 'cdk-menu-item',\n                        '[tabindex]': '_tabindex',\n                        '[attr.aria-disabled]': 'disabled || null',\n                        '(blur)': '_resetTabIndex()',\n                        '(focus)': '_setTabIndex()',\n                        '(click)': 'trigger()',\n                        '(keydown)': '_onKeydown($event)',\n                    },\n                }]\n        }], ctorParameters: function () { return []; }, propDecorators: { disabled: [{\n                type: Input,\n                args: ['cdkMenuItemDisabled']\n            }], typeaheadLabel: [{\n                type: Input,\n                args: ['cdkMenuitemTypeaheadLabel']\n            }], triggered: [{\n                type: Output,\n                args: ['cdkMenuItemTriggered']\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * PointerFocusTracker keeps track of the currently active item under mouse focus. It also has\n * observables which emit when the users mouse enters and leaves a tracked element.\n */\nclass PointerFocusTracker {\n    constructor(\n    /** The list of items being tracked. */\n    _items) {\n        this._items = _items;\n        /** Emits when an element is moused into. */\n        this.entered = this._getItemPointerEntries();\n        /** Emits when an element is moused out. */\n        this.exited = this._getItemPointerExits();\n        /** Emits when this is destroyed. */\n        this._destroyed = new Subject();\n        this.entered.subscribe(element => (this.activeElement = element));\n        this.exited.subscribe(() => {\n            this.previousElement = this.activeElement;\n            this.activeElement = undefined;\n        });\n    }\n    /** Stop the managers listeners. */\n    destroy() {\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /**\n     * Gets a stream of pointer (mouse) entries into the given items.\n     * This should typically run outside the Angular zone.\n     */\n    _getItemPointerEntries() {\n        return defer(() => this._items.changes.pipe(startWith(this._items), mergeMap((list) => list.map(element => fromEvent(element._elementRef.nativeElement, 'mouseenter').pipe(mapTo(element), takeUntil(this._items.changes)))), mergeAll()));\n    }\n    /**\n     * Gets a stream of pointer (mouse) exits out of the given items.\n     * This should typically run outside the Angular zone.\n     */\n    _getItemPointerExits() {\n        return defer(() => this._items.changes.pipe(startWith(this._items), mergeMap((list) => list.map(element => fromEvent(element._elementRef.nativeElement, 'mouseout').pipe(mapTo(element), takeUntil(this._items.changes)))), mergeAll()));\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Counter used to create unique IDs for menus. */\nlet nextId$1 = 0;\n/**\n * Abstract directive that implements shared logic common to all menus.\n * This class can be extended to create custom menu types.\n */\nclass CdkMenuBase extends CdkMenuGroup {\n    constructor() {\n        super(...arguments);\n        /** The menu's native DOM host element. */\n        this.nativeElement = inject(ElementRef).nativeElement;\n        /** The Angular zone. */\n        this.ngZone = inject(NgZone);\n        /** The stack of menus this menu belongs to. */\n        this.menuStack = inject(MENU_STACK);\n        /** The menu aim service used by this menu. */\n        this.menuAim = inject(MENU_AIM, InjectFlags.Optional | InjectFlags.Self);\n        /** The directionality (text direction) of the current page. */\n        this.dir = inject(Directionality, InjectFlags.Optional);\n        /** The id of the menu's host element. */\n        this.id = `cdk-menu-${nextId$1++}`;\n        /** The direction items in the menu flow. */\n        this.orientation = 'vertical';\n        /**\n         * Whether the menu is displayed inline (i.e. always present vs a conditional popup that the\n         * user triggers with a trigger element).\n         */\n        this.isInline = false;\n        /** Emits when the MenuBar is destroyed. */\n        this.destroyed = new Subject();\n        /** Whether this menu's menu stack has focus. */\n        this._menuStackHasFocus = false;\n    }\n    ngAfterContentInit() {\n        if (!this.isInline) {\n            this.menuStack.push(this);\n        }\n        this._setKeyManager();\n        this._subscribeToMenuStackHasFocus();\n        this._subscribeToMenuOpen();\n        this._subscribeToMenuStackClosed();\n        this._setUpPointerTracker();\n    }\n    ngOnDestroy() {\n        this.destroyed.next();\n        this.destroyed.complete();\n        this.pointerTracker?.destroy();\n    }\n    /**\n     * Place focus on the first MenuItem in the menu and set the focus origin.\n     * @param focusOrigin The origin input mode of the focus event.\n     */\n    focusFirstItem(focusOrigin = 'program') {\n        this.keyManager.setFocusOrigin(focusOrigin);\n        this.keyManager.setFirstItemActive();\n    }\n    /**\n     * Place focus on the last MenuItem in the menu and set the focus origin.\n     * @param focusOrigin The origin input mode of the focus event.\n     */\n    focusLastItem(focusOrigin = 'program') {\n        this.keyManager.setFocusOrigin(focusOrigin);\n        this.keyManager.setLastItemActive();\n    }\n    /** Gets the tabindex for this menu. */\n    _getTabIndex() {\n        const tabindexIfInline = this._menuStackHasFocus ? -1 : 0;\n        return this.isInline ? tabindexIfInline : null;\n    }\n    /**\n     * Close the open menu if the current active item opened the requested MenuStackItem.\n     * @param menu The menu requested to be closed.\n     * @param options Options to configure the behavior on close.\n     *   - `focusParentTrigger` Whether to focus the parent trigger after closing the menu.\n     */\n    closeOpenMenu(menu, options) {\n        const { focusParentTrigger } = { ...options };\n        const keyManager = this.keyManager;\n        const trigger = this.triggerItem;\n        if (menu === trigger?.getMenuTrigger()?.getMenu()) {\n            trigger?.getMenuTrigger()?.close();\n            // If the user has moused over a sibling item we want to focus the element under mouse focus\n            // not the trigger which previously opened the now closed menu.\n            if (focusParentTrigger) {\n                if (trigger) {\n                    keyManager.setActiveItem(trigger);\n                }\n                else {\n                    keyManager.setFirstItemActive();\n                }\n            }\n        }\n    }\n    /** Setup the FocusKeyManager with the correct orientation for the menu. */\n    _setKeyManager() {\n        this.keyManager = new FocusKeyManager(this.items).withWrap().withTypeAhead().withHomeAndEnd();\n        if (this.orientation === 'horizontal') {\n            this.keyManager.withHorizontalOrientation(this.dir?.value || 'ltr');\n        }\n        else {\n            this.keyManager.withVerticalOrientation();\n        }\n    }\n    /**\n     * Subscribe to the menu trigger's open events in order to track the trigger which opened the menu\n     * and stop tracking it when the menu is closed.\n     */\n    _subscribeToMenuOpen() {\n        const exitCondition = merge(this.items.changes, this.destroyed);\n        this.items.changes\n            .pipe(startWith(this.items), mergeMap((list) => list\n            .filter(item => item.hasMenu)\n            .map(item => item.getMenuTrigger().opened.pipe(mapTo(item), takeUntil(exitCondition)))), mergeAll(), switchMap((item) => {\n            this.triggerItem = item;\n            return item.getMenuTrigger().closed;\n        }), takeUntil(this.destroyed))\n            .subscribe(() => (this.triggerItem = undefined));\n    }\n    /** Subscribe to the MenuStack close events. */\n    _subscribeToMenuStackClosed() {\n        this.menuStack.closed\n            .pipe(takeUntil(this.destroyed))\n            .subscribe(({ item, focusParentTrigger }) => this.closeOpenMenu(item, { focusParentTrigger }));\n    }\n    /** Subscribe to the MenuStack hasFocus events. */\n    _subscribeToMenuStackHasFocus() {\n        if (this.isInline) {\n            this.menuStack.hasFocus.pipe(takeUntil(this.destroyed)).subscribe(hasFocus => {\n                this._menuStackHasFocus = hasFocus;\n            });\n        }\n    }\n    /**\n     * Set the PointerFocusTracker and ensure that when mouse focus changes the key manager is updated\n     * with the latest menu item under mouse focus.\n     */\n    _setUpPointerTracker() {\n        if (this.menuAim) {\n            this.ngZone.runOutsideAngular(() => {\n                this.pointerTracker = new PointerFocusTracker(this.items);\n            });\n            this.menuAim.initialize(this, this.pointerTracker);\n        }\n    }\n}\nCdkMenuBase.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkMenuBase, deps: null, target: i0.ɵɵFactoryTarget.Directive });\nCdkMenuBase.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.0\", type: CdkMenuBase, inputs: { id: \"id\" }, host: { attributes: { \"role\": \"menu\" }, listeners: { \"focus\": \"focusFirstItem()\", \"focusin\": \"menuStack.setHasFocus(true)\", \"focusout\": \"menuStack.setHasFocus(false)\" }, properties: { \"tabindex\": \"_getTabIndex()\", \"id\": \"id\", \"attr.aria-orientation\": \"orientation\", \"attr.data-cdk-menu-stack-id\": \"menuStack.id\" } }, queries: [{ propertyName: \"items\", predicate: CdkMenuItem, descendants: true }], usesInheritance: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkMenuBase, decorators: [{\n            type: Directive,\n            args: [{\n                    host: {\n                        'role': 'menu',\n                        'class': '',\n                        '[tabindex]': '_getTabIndex()',\n                        '[id]': 'id',\n                        '[attr.aria-orientation]': 'orientation',\n                        '[attr.data-cdk-menu-stack-id]': 'menuStack.id',\n                        '(focus)': 'focusFirstItem()',\n                        '(focusin)': 'menuStack.setHasFocus(true)',\n                        '(focusout)': 'menuStack.setHasFocus(false)',\n                    },\n                }]\n        }], propDecorators: { id: [{\n                type: Input\n            }], items: [{\n                type: ContentChildren,\n                args: [CdkMenuItem, { descendants: true }]\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Directive which configures the element as a Menu which should contain child elements marked as\n * CdkMenuItem or CdkMenuGroup. Sets the appropriate role and aria-attributes for a menu and\n * contains accessible keyboard and mouse handling logic.\n *\n * It also acts as a RadioGroup for elements marked with role `menuitemradio`.\n */\nclass CdkMenu extends CdkMenuBase {\n    constructor() {\n        super();\n        this._parentTrigger = inject(MENU_TRIGGER, InjectFlags.Optional);\n        /** Event emitted when the menu is closed. */\n        this.closed = new EventEmitter();\n        /** The direction items in the menu flow. */\n        this.orientation = 'vertical';\n        /** Whether the menu is displayed inline (i.e. always present vs a conditional popup that the user triggers with a trigger element). */\n        this.isInline = !this._parentTrigger;\n        this.destroyed.subscribe(this.closed);\n        this._parentTrigger?.registerChildMenu(this);\n    }\n    ngAfterContentInit() {\n        super.ngAfterContentInit();\n        this._subscribeToMenuStackEmptied();\n    }\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        this.closed.complete();\n    }\n    /**\n     * Handle keyboard events for the Menu.\n     * @param event The keyboard event to be handled.\n     */\n    _handleKeyEvent(event) {\n        const keyManager = this.keyManager;\n        switch (event.keyCode) {\n            case LEFT_ARROW:\n            case RIGHT_ARROW:\n                if (!hasModifierKey(event)) {\n                    event.preventDefault();\n                    keyManager.setFocusOrigin('keyboard');\n                    keyManager.onKeydown(event);\n                }\n                break;\n            case ESCAPE:\n                if (!hasModifierKey(event)) {\n                    event.preventDefault();\n                    this.menuStack.close(this, {\n                        focusNextOnEmpty: 2 /* FocusNext.currentItem */,\n                        focusParentTrigger: true,\n                    });\n                }\n                break;\n            case TAB:\n                if (!hasModifierKey(event, 'altKey', 'metaKey', 'ctrlKey')) {\n                    this.menuStack.closeAll({ focusParentTrigger: true });\n                }\n                break;\n            default:\n                keyManager.onKeydown(event);\n        }\n    }\n    /**\n     * Set focus the either the current, previous or next item based on the FocusNext event.\n     * @param focusNext The element to focus.\n     */\n    _toggleMenuFocus(focusNext) {\n        const keyManager = this.keyManager;\n        switch (focusNext) {\n            case 0 /* FocusNext.nextItem */:\n                keyManager.setFocusOrigin('keyboard');\n                keyManager.setNextItemActive();\n                break;\n            case 1 /* FocusNext.previousItem */:\n                keyManager.setFocusOrigin('keyboard');\n                keyManager.setPreviousItemActive();\n                break;\n            case 2 /* FocusNext.currentItem */:\n                if (keyManager.activeItem) {\n                    keyManager.setFocusOrigin('keyboard');\n                    keyManager.setActiveItem(keyManager.activeItem);\n                }\n                break;\n        }\n    }\n    /** Subscribe to the MenuStack emptied events. */\n    _subscribeToMenuStackEmptied() {\n        this.menuStack.emptied\n            .pipe(takeUntil(this.destroyed))\n            .subscribe(event => this._toggleMenuFocus(event));\n    }\n}\nCdkMenu.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkMenu, deps: [], target: i0.ɵɵFactoryTarget.Directive });\nCdkMenu.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.0\", type: CdkMenu, selector: \"[cdkMenu]\", outputs: { closed: \"closed\" }, host: { attributes: { \"role\": \"menu\" }, listeners: { \"keydown\": \"_handleKeyEvent($event)\" }, properties: { \"class.cdk-menu-inline\": \"isInline\" }, classAttribute: \"cdk-menu\" }, providers: [\n        { provide: CdkMenuGroup, useExisting: CdkMenu },\n        { provide: CDK_MENU, useExisting: CdkMenu },\n        PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER('vertical'),\n    ], exportAs: [\"cdkMenu\"], usesInheritance: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkMenu, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkMenu]',\n                    exportAs: 'cdkMenu',\n                    host: {\n                        'role': 'menu',\n                        'class': 'cdk-menu',\n                        '[class.cdk-menu-inline]': 'isInline',\n                        '(keydown)': '_handleKeyEvent($event)',\n                    },\n                    providers: [\n                        { provide: CdkMenuGroup, useExisting: CdkMenu },\n                        { provide: CDK_MENU, useExisting: CdkMenu },\n                        PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER('vertical'),\n                    ],\n                }]\n        }], ctorParameters: function () { return []; }, propDecorators: { closed: [{\n                type: Output\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Directive applied to an element which configures it as a MenuBar by setting the appropriate\n * role, aria attributes, and accessible keyboard and mouse handling logic. The component that\n * this directive is applied to should contain components marked with CdkMenuItem.\n *\n */\nclass CdkMenuBar extends CdkMenuBase {\n    constructor() {\n        super(...arguments);\n        /** The direction items in the menu flow. */\n        this.orientation = 'horizontal';\n        /** Whether the menu is displayed inline (i.e. always present vs a conditional popup that the user triggers with a trigger element). */\n        this.isInline = true;\n    }\n    ngAfterContentInit() {\n        super.ngAfterContentInit();\n        this._subscribeToMenuStackEmptied();\n    }\n    /**\n     * Handle keyboard events for the Menu.\n     * @param event The keyboard event to be handled.\n     */\n    _handleKeyEvent(event) {\n        const keyManager = this.keyManager;\n        switch (event.keyCode) {\n            case UP_ARROW:\n            case DOWN_ARROW:\n            case LEFT_ARROW:\n            case RIGHT_ARROW:\n                if (!hasModifierKey(event)) {\n                    const horizontalArrows = event.keyCode === LEFT_ARROW || event.keyCode === RIGHT_ARROW;\n                    // For a horizontal menu if the left/right keys were clicked, or a vertical menu if the\n                    // up/down keys were clicked: if the current menu is open, close it then focus and open the\n                    // next  menu.\n                    if (horizontalArrows) {\n                        event.preventDefault();\n                        const prevIsOpen = keyManager.activeItem?.isMenuOpen();\n                        keyManager.activeItem?.getMenuTrigger()?.close();\n                        keyManager.setFocusOrigin('keyboard');\n                        keyManager.onKeydown(event);\n                        if (prevIsOpen) {\n                            keyManager.activeItem?.getMenuTrigger()?.open();\n                        }\n                    }\n                }\n                break;\n            case ESCAPE:\n                if (!hasModifierKey(event)) {\n                    event.preventDefault();\n                    keyManager.activeItem?.getMenuTrigger()?.close();\n                }\n                break;\n            case TAB:\n                if (!hasModifierKey(event, 'altKey', 'metaKey', 'ctrlKey')) {\n                    keyManager.activeItem?.getMenuTrigger()?.close();\n                }\n                break;\n            default:\n                keyManager.onKeydown(event);\n        }\n    }\n    /**\n     * Set focus to either the current, previous or next item based on the FocusNext event, then\n     * open the previous or next item.\n     * @param focusNext The element to focus.\n     */\n    _toggleOpenMenu(focusNext) {\n        const keyManager = this.keyManager;\n        switch (focusNext) {\n            case 0 /* FocusNext.nextItem */:\n                keyManager.setFocusOrigin('keyboard');\n                keyManager.setNextItemActive();\n                keyManager.activeItem?.getMenuTrigger()?.open();\n                break;\n            case 1 /* FocusNext.previousItem */:\n                keyManager.setFocusOrigin('keyboard');\n                keyManager.setPreviousItemActive();\n                keyManager.activeItem?.getMenuTrigger()?.open();\n                break;\n            case 2 /* FocusNext.currentItem */:\n                if (keyManager.activeItem) {\n                    keyManager.setFocusOrigin('keyboard');\n                    keyManager.setActiveItem(keyManager.activeItem);\n                }\n                break;\n        }\n    }\n    /** Subscribe to the MenuStack emptied events. */\n    _subscribeToMenuStackEmptied() {\n        this.menuStack?.emptied\n            .pipe(takeUntil(this.destroyed))\n            .subscribe(event => this._toggleOpenMenu(event));\n    }\n}\nCdkMenuBar.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkMenuBar, deps: null, target: i0.ɵɵFactoryTarget.Directive });\nCdkMenuBar.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.0\", type: CdkMenuBar, selector: \"[cdkMenuBar]\", host: { attributes: { \"role\": \"menubar\" }, listeners: { \"keydown\": \"_handleKeyEvent($event)\" }, classAttribute: \"cdk-menu-bar\" }, providers: [\n        { provide: CdkMenuGroup, useExisting: CdkMenuBar },\n        { provide: CDK_MENU, useExisting: CdkMenuBar },\n        { provide: MENU_STACK, useFactory: () => MenuStack.inline('horizontal') },\n    ], exportAs: [\"cdkMenuBar\"], usesInheritance: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkMenuBar, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkMenuBar]',\n                    exportAs: 'cdkMenuBar',\n                    host: {\n                        'role': 'menubar',\n                        'class': 'cdk-menu-bar',\n                        '(keydown)': '_handleKeyEvent($event)',\n                    },\n                    providers: [\n                        { provide: CdkMenuGroup, useExisting: CdkMenuBar },\n                        { provide: CDK_MENU, useExisting: CdkMenuBar },\n                        { provide: MENU_STACK, useFactory: () => MenuStack.inline('horizontal') },\n                    ],\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Base class providing checked state for selectable MenuItems. */\nclass CdkMenuItemSelectable extends CdkMenuItem {\n    constructor() {\n        super(...arguments);\n        this._checked = false;\n        /** Whether the item should close the menu if triggered by the spacebar. */\n        this.closeOnSpacebarTrigger = false;\n    }\n    /** Whether the element is checked */\n    get checked() {\n        return this._checked;\n    }\n    set checked(value) {\n        this._checked = coerceBooleanProperty(value);\n    }\n}\nCdkMenuItemSelectable.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkMenuItemSelectable, deps: null, target: i0.ɵɵFactoryTarget.Directive });\nCdkMenuItemSelectable.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.0\", type: CdkMenuItemSelectable, inputs: { checked: [\"cdkMenuItemChecked\", \"checked\"] }, host: { properties: { \"attr.aria-checked\": \"!!checked\", \"attr.aria-disabled\": \"disabled || null\" } }, usesInheritance: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkMenuItemSelectable, decorators: [{\n            type: Directive,\n            args: [{\n                    host: {\n                        '[attr.aria-checked]': '!!checked',\n                        '[attr.aria-disabled]': 'disabled || null',\n                    },\n                }]\n        }], propDecorators: { checked: [{\n                type: Input,\n                args: ['cdkMenuItemChecked']\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Counter used to set a unique id and name for a selectable item */\nlet nextId = 0;\n/**\n * A directive providing behavior for the \"menuitemradio\" ARIA role, which behaves similarly to\n * a conventional radio-button. Any sibling `CdkMenuItemRadio` instances within the same `CdkMenu`\n * or `CdkMenuGroup` comprise a radio group with unique selection enforced.\n */\nclass CdkMenuItemRadio extends CdkMenuItemSelectable {\n    constructor() {\n        super();\n        /** The unique selection dispatcher for this radio's `CdkMenuGroup`. */\n        this._selectionDispatcher = inject(UniqueSelectionDispatcher);\n        /** An ID to identify this radio item to the `UniqueSelectionDispatcher`. */\n        this._id = `${nextId++}`;\n        this._registerDispatcherListener();\n    }\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        this._removeDispatcherListener();\n    }\n    /**\n     * Toggles the checked state of the radio-button.\n     * @param options Options the configure how the item is triggered\n     *   - keepOpen: specifies that the menu should be kept open after triggering the item.\n     */\n    trigger(options) {\n        super.trigger(options);\n        if (!this.disabled) {\n            this._selectionDispatcher.notify(this._id, '');\n        }\n    }\n    /** Configure the unique selection dispatcher listener in order to toggle the checked state  */\n    _registerDispatcherListener() {\n        this._removeDispatcherListener = this._selectionDispatcher.listen((id) => {\n            this.checked = this._id === id;\n        });\n    }\n}\nCdkMenuItemRadio.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkMenuItemRadio, deps: [], target: i0.ɵɵFactoryTarget.Directive });\nCdkMenuItemRadio.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.0\", type: CdkMenuItemRadio, selector: \"[cdkMenuItemRadio]\", host: { attributes: { \"role\": \"menuitemradio\" }, properties: { \"class.cdk-menu-item-radio\": \"true\" } }, providers: [\n        { provide: CdkMenuItemSelectable, useExisting: CdkMenuItemRadio },\n        { provide: CdkMenuItem, useExisting: CdkMenuItemSelectable },\n    ], exportAs: [\"cdkMenuItemRadio\"], usesInheritance: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkMenuItemRadio, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkMenuItemRadio]',\n                    exportAs: 'cdkMenuItemRadio',\n                    host: {\n                        'role': 'menuitemradio',\n                        '[class.cdk-menu-item-radio]': 'true',\n                    },\n                    providers: [\n                        { provide: CdkMenuItemSelectable, useExisting: CdkMenuItemRadio },\n                        { provide: CdkMenuItem, useExisting: CdkMenuItemSelectable },\n                    ],\n                }]\n        }], ctorParameters: function () { return []; } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A directive providing behavior for the \"menuitemcheckbox\" ARIA role, which behaves similarly to a\n * conventional checkbox.\n */\nclass CdkMenuItemCheckbox extends CdkMenuItemSelectable {\n    /**\n     * Toggle the checked state of the checkbox.\n     * @param options Options the configure how the item is triggered\n     *   - keepOpen: specifies that the menu should be kept open after triggering the item.\n     */\n    trigger(options) {\n        super.trigger(options);\n        if (!this.disabled) {\n            this.checked = !this.checked;\n        }\n    }\n}\nCdkMenuItemCheckbox.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkMenuItemCheckbox, deps: null, target: i0.ɵɵFactoryTarget.Directive });\nCdkMenuItemCheckbox.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.0\", type: CdkMenuItemCheckbox, selector: \"[cdkMenuItemCheckbox]\", host: { attributes: { \"role\": \"menuitemcheckbox\" }, properties: { \"class.cdk-menu-item-checkbox\": \"true\" } }, providers: [\n        { provide: CdkMenuItemSelectable, useExisting: CdkMenuItemCheckbox },\n        { provide: CdkMenuItem, useExisting: CdkMenuItemSelectable },\n    ], exportAs: [\"cdkMenuItemCheckbox\"], usesInheritance: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkMenuItemCheckbox, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkMenuItemCheckbox]',\n                    exportAs: 'cdkMenuItemCheckbox',\n                    host: {\n                        'role': 'menuitemcheckbox',\n                        '[class.cdk-menu-item-checkbox]': 'true',\n                    },\n                    providers: [\n                        { provide: CdkMenuItemSelectable, useExisting: CdkMenuItemCheckbox },\n                        { provide: CdkMenuItem, useExisting: CdkMenuItemSelectable },\n                    ],\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** The preferred menu positions for the context menu. */\nconst CONTEXT_MENU_POSITIONS = STANDARD_DROPDOWN_BELOW_POSITIONS.map(position => {\n    // In cases where the first menu item in the context menu is a trigger the submenu opens on a\n    // hover event. We offset the context menu 2px by default to prevent this from occurring.\n    const offsetX = position.overlayX === 'start' ? 2 : -2;\n    const offsetY = position.overlayY === 'top' ? 2 : -2;\n    return { ...position, offsetX, offsetY };\n});\n/** Tracks the last open context menu trigger across the entire application. */\nclass ContextMenuTracker {\n    /**\n     * Close the previous open context menu and set the given one as being open.\n     * @param trigger The trigger for the currently open Context Menu.\n     */\n    update(trigger) {\n        if (ContextMenuTracker._openContextMenuTrigger !== trigger) {\n            ContextMenuTracker._openContextMenuTrigger?.close();\n            ContextMenuTracker._openContextMenuTrigger = trigger;\n        }\n    }\n}\nContextMenuTracker.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: ContextMenuTracker, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nContextMenuTracker.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: ContextMenuTracker, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: ContextMenuTracker, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n/**\n * A directive that opens a menu when a user right-clicks within its host element.\n * It is aware of nested context menus and will trigger only the lowest level non-disabled context menu.\n */\nclass CdkContextMenuTrigger extends CdkMenuTriggerBase {\n    constructor() {\n        super();\n        /** The CDK overlay service. */\n        this._overlay = inject(Overlay);\n        /** The directionality of the page. */\n        this._directionality = inject(Directionality, InjectFlags.Optional);\n        /** The app's context menu tracking registry */\n        this._contextMenuTracker = inject(ContextMenuTracker);\n        this._disabled = false;\n        this._setMenuStackCloseListener();\n    }\n    /** Whether the context menu is disabled. */\n    get disabled() {\n        return this._disabled;\n    }\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n    }\n    /**\n     * Open the attached menu at the specified location.\n     * @param coordinates where to open the context menu\n     */\n    open(coordinates) {\n        this._open(coordinates, false);\n    }\n    /** Close the currently opened context menu. */\n    close() {\n        this.menuStack.closeAll();\n    }\n    /**\n     * Open the context menu and closes any previously open menus.\n     * @param event the mouse event which opens the context menu.\n     */\n    _openOnContextMenu(event) {\n        if (!this.disabled) {\n            // Prevent the native context menu from opening because we're opening a custom one.\n            event.preventDefault();\n            // Stop event propagation to ensure that only the closest enabled context menu opens.\n            // Otherwise, any context menus attached to containing elements would *also* open,\n            // resulting in multiple stacked context menus being displayed.\n            event.stopPropagation();\n            this._contextMenuTracker.update(this);\n            this._open({ x: event.clientX, y: event.clientY }, true);\n            // A context menu can be triggered via a mouse right click or a keyboard shortcut.\n            if (event.button === 2) {\n                this.childMenu?.focusFirstItem('mouse');\n            }\n            else if (event.button === 0) {\n                this.childMenu?.focusFirstItem('keyboard');\n            }\n            else {\n                this.childMenu?.focusFirstItem('program');\n            }\n        }\n    }\n    /**\n     * Get the configuration object used to create the overlay.\n     * @param coordinates the location to place the opened menu\n     */\n    _getOverlayConfig(coordinates) {\n        return new OverlayConfig({\n            positionStrategy: this._getOverlayPositionStrategy(coordinates),\n            scrollStrategy: this._overlay.scrollStrategies.reposition(),\n            direction: this._directionality || undefined,\n        });\n    }\n    /**\n     * Get the position strategy for the overlay which specifies where to place the menu.\n     * @param coordinates the location to place the opened menu\n     */\n    _getOverlayPositionStrategy(coordinates) {\n        return this._overlay\n            .position()\n            .flexibleConnectedTo(coordinates)\n            .withLockedPosition()\n            .withGrowAfterOpen()\n            .withPositions(this.menuPosition ?? CONTEXT_MENU_POSITIONS);\n    }\n    /** Subscribe to the menu stack close events and close this menu when requested. */\n    _setMenuStackCloseListener() {\n        this.menuStack.closed.pipe(takeUntil(this.destroyed)).subscribe(({ item }) => {\n            if (item === this.childMenu && this.isOpen()) {\n                this.closed.next();\n                this.overlayRef.detach();\n            }\n        });\n    }\n    /**\n     * Subscribe to the overlays outside pointer events stream and handle closing out the stack if a\n     * click occurs outside the menus.\n     * @param ignoreFirstAuxClick Whether to ignore the first auxclick event outside the menu.\n     */\n    _subscribeToOutsideClicks(ignoreFirstAuxClick) {\n        if (this.overlayRef) {\n            let outsideClicks = this.overlayRef.outsidePointerEvents();\n            // If the menu was triggered by the `contextmenu` event, skip the first `auxclick` event\n            // because it fires when the mouse is released on the same click that opened the menu.\n            if (ignoreFirstAuxClick) {\n                const [auxClicks, nonAuxClicks] = partition(outsideClicks, ({ type }) => type === 'auxclick');\n                outsideClicks = merge(nonAuxClicks, auxClicks.pipe(skip(1)));\n            }\n            outsideClicks.pipe(takeUntil(this.stopOutsideClicksListener)).subscribe(event => {\n                if (!this.isElementInsideMenuStack(event.target)) {\n                    this.menuStack.closeAll();\n                }\n            });\n        }\n    }\n    /**\n     * Open the attached menu at the specified location.\n     * @param coordinates where to open the context menu\n     * @param ignoreFirstOutsideAuxClick Whether to ignore the first auxclick outside the menu after opening.\n     */\n    _open(coordinates, ignoreFirstOutsideAuxClick) {\n        if (this.disabled) {\n            return;\n        }\n        if (this.isOpen()) {\n            // since we're moving this menu we need to close any submenus first otherwise they end up\n            // disconnected from this one.\n            this.menuStack.closeSubMenuOf(this.childMenu);\n            this.overlayRef.getConfig().positionStrategy.setOrigin(coordinates);\n            this.overlayRef.updatePosition();\n        }\n        else {\n            this.opened.next();\n            if (this.overlayRef) {\n                this.overlayRef.getConfig().positionStrategy.setOrigin(coordinates);\n                this.overlayRef.updatePosition();\n            }\n            else {\n                this.overlayRef = this._overlay.create(this._getOverlayConfig(coordinates));\n            }\n            this.overlayRef.attach(this.getMenuContentPortal());\n            this._subscribeToOutsideClicks(ignoreFirstOutsideAuxClick);\n        }\n    }\n}\nCdkContextMenuTrigger.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkContextMenuTrigger, deps: [], target: i0.ɵɵFactoryTarget.Directive });\nCdkContextMenuTrigger.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.0\", type: CdkContextMenuTrigger, selector: \"[cdkContextMenuTriggerFor]\", inputs: { menuTemplateRef: [\"cdkContextMenuTriggerFor\", \"menuTemplateRef\"], menuPosition: [\"cdkContextMenuPosition\", \"menuPosition\"], disabled: [\"cdkContextMenuDisabled\", \"disabled\"] }, outputs: { opened: \"cdkContextMenuOpened\", closed: \"cdkContextMenuClosed\" }, host: { listeners: { \"contextmenu\": \"_openOnContextMenu($event)\" }, properties: { \"attr.data-cdk-menu-stack-id\": \"null\" } }, providers: [\n        { provide: MENU_TRIGGER, useExisting: CdkContextMenuTrigger },\n        { provide: MENU_STACK, useClass: MenuStack },\n    ], exportAs: [\"cdkContextMenuTriggerFor\"], usesInheritance: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkContextMenuTrigger, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkContextMenuTriggerFor]',\n                    exportAs: 'cdkContextMenuTriggerFor',\n                    host: {\n                        '[attr.data-cdk-menu-stack-id]': 'null',\n                        '(contextmenu)': '_openOnContextMenu($event)',\n                    },\n                    inputs: ['menuTemplateRef: cdkContextMenuTriggerFor', 'menuPosition: cdkContextMenuPosition'],\n                    outputs: ['opened: cdkContextMenuOpened', 'closed: cdkContextMenuClosed'],\n                    providers: [\n                        { provide: MENU_TRIGGER, useExisting: CdkContextMenuTrigger },\n                        { provide: MENU_STACK, useClass: MenuStack },\n                    ],\n                }]\n        }], ctorParameters: function () { return []; }, propDecorators: { disabled: [{\n                type: Input,\n                args: ['cdkContextMenuDisabled']\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** The list of components and directives that should be declared and exported from this module. */\nconst EXPORTED_DECLARATIONS = [\n    CdkMenuBar,\n    CdkMenu,\n    CdkMenuItem,\n    CdkMenuItemRadio,\n    CdkMenuItemCheckbox,\n    CdkMenuTrigger,\n    CdkMenuGroup,\n    CdkContextMenuTrigger,\n    CdkTargetMenuAim,\n];\n/** Module that declares components and directives for the CDK menu. */\nclass CdkMenuModule {\n}\nCdkMenuModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkMenuModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nCdkMenuModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkMenuModule, declarations: [CdkMenuBar,\n        CdkMenu,\n        CdkMenuItem,\n        CdkMenuItemRadio,\n        CdkMenuItemCheckbox,\n        CdkMenuTrigger,\n        CdkMenuGroup,\n        CdkContextMenuTrigger,\n        CdkTargetMenuAim], imports: [OverlayModule], exports: [CdkMenuBar,\n        CdkMenu,\n        CdkMenuItem,\n        CdkMenuItemRadio,\n        CdkMenuItemCheckbox,\n        CdkMenuTrigger,\n        CdkMenuGroup,\n        CdkContextMenuTrigger,\n        CdkTargetMenuAim] });\nCdkMenuModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkMenuModule, imports: [OverlayModule] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkMenuModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [OverlayModule],\n                    exports: EXPORTED_DECLARATIONS,\n                    declarations: EXPORTED_DECLARATIONS,\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CDK_MENU, CdkContextMenuTrigger, CdkMenu, CdkMenuBar, CdkMenuBase, CdkMenuGroup, CdkMenuItem, CdkMenuItemCheckbox, CdkMenuItemRadio, CdkMenuItemSelectable, CdkMenuModule, CdkMenuTrigger, CdkMenuTriggerBase, CdkTargetMenuAim, ContextMenuTracker, MENU_AIM, MENU_STACK, MENU_TRIGGER, MenuStack, PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER, PARENT_OR_NEW_MENU_STACK_PROVIDER, PointerFocusTracker, TargetMenuAim };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}